<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste - Pipeline de Processamento RAG</title>
    <link rel="stylesheet" href="../css/main.css">
    <style>
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
        }
        .test-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        .test-output {
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            padding: 15px;
            font-family: monospace;
            font-size: 0.9em;
            max-height: 400px;
            overflow-y: auto;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-online { background: var(--success-color); }
        .status-offline { background: var(--danger-color); }
        .status-checking { background: var(--warning-color); }
        .sample-data {
            margin-top: 10px;
            padding: 10px;
            background: var(--bg-primary);
            border-radius: var(--border-radius);
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid var(--border-color);
        }
        .log-success { border-color: var(--success-color); }
        .log-error { border-color: var(--danger-color); }
        .log-info { border-color: var(--info-color); }
    </style>
</head>
<body>
    <h1>üß™ Teste do Pipeline de Processamento RAG</h1>
    
    <!-- Status dos Servi√ßos -->
    <div class="test-section">
        <h2>üîå Status dos Servi√ßos</h2>
        <div>
            <span id="ollama-status" class="status-indicator status-checking"></span>
            <strong>Ollama:</strong> <span id="ollama-text">Verificando...</span>
        </div>
        <div>
            <span id="qdrant-status" class="status-indicator status-checking"></span>
            <strong>Qdrant:</strong> <span id="qdrant-text">Verificando...</span>
        </div>
        <div class="test-controls">
            <button onclick="checkServices()">Verificar Servi√ßos</button>
        </div>
    </div>

    <!-- Dados de Teste -->
    <div class="test-section">
        <h2>üìÑ Dados de Teste</h2>
        <div class="test-controls">
            <button onclick="createTestData()">Criar Dados de Teste</button>
            <button onclick="loadExistingData()">Carregar Dados Existentes</button>
            <button onclick="clearTestData()">Limpar Dados</button>
        </div>
        <div id="data-status" class="test-output">
            <p>Nenhum dado carregado</p>
        </div>
    </div>

    <!-- Pipeline de Processamento -->
    <div class="test-section">
        <h2>üöÄ Pipeline de Processamento</h2>
        <div class="test-controls">
            <button id="btn-process" onclick="runPipeline()" disabled>Executar Pipeline</button>
            <button onclick="testConsolidation()">Testar Consolida√ß√£o</button>
            <button onclick="testChunking()">Testar Chunking</button>
            <button onclick="testEmbedding()">Testar Embeddings</button>
            <button onclick="testQdrantInsert()">Testar Inser√ß√£o Qdrant</button>
        </div>
        <div id="pipeline-progress" style="display: none; margin: 10px 0;">
            <div class="progress-bar">
                <div id="progress-fill" class="progress-bar-fill" style="width: 0%"></div>
            </div>
            <span id="progress-text">0%</span>
        </div>
        <div id="pipeline-output" class="test-output">
            <p>Aguardando execu√ß√£o...</p>
        </div>
    </div>

    <!-- Busca Sem√¢ntica -->
    <div class="test-section">
        <h2>üîç Teste de Busca Sem√¢ntica</h2>
        <div class="test-controls">
            <input type="text" id="search-query" placeholder="Digite sua busca..." style="flex: 1;">
            <button onclick="searchSemantic()">Buscar</button>
        </div>
        <div id="search-results" class="test-output">
            <p>Digite algo para buscar...</p>
        </div>
    </div>

    <!-- Scripts -->
    <script src="../js/core/EventBus.js"></script>
    <script src="../js/core/AppState.js"></script>
    <script src="../js/core/Logger.js"></script>
    <script src="../js/utils/PreviewUtils.js"></script>
    <script src="../js/utils/ChunkingUtils.js"></script>
    <script src="../js/managers/CategoryManager.js"></script>
    <script src="../js/managers/RAGExportManager.js"></script>
    <script src="../js/services/EmbeddingService.js"></script>
    <script src="../js/services/QdrantService.js"></script>
    <script src="../js/utils/fix-relevance-scores.js"></script>

    <script>
        const KC = window.KnowledgeConsolidator;
        let testData = null;

        // Inicializa√ß√£o
        window.onload = async () => {
            log('info', 'P√°gina de teste carregada');
            await checkServices();
            setupEventListeners();
        };

        // Configura listeners
        function setupEventListeners() {
            KC.EventBus.on(KC.Events.PIPELINE_PROGRESS, (data) => {
                updateProgress(data.percentage, `${data.current}/${data.total}`);
            });

            KC.EventBus.on(KC.Events.PIPELINE_COMPLETED, (data) => {
                if (data.success) {
                    log('success', 'Pipeline conclu√≠do com sucesso!');
                    log('info', `Processados: ${data.results.processed} documentos`);
                    log('info', `Chunks: ${data.results.totalChunks}`);
                    if (data.results.failed > 0) {
                        log('error', `Falhas: ${data.results.failed}`);
                    }
                } else {
                    log('error', `Pipeline falhou: ${data.error}`);
                }
                hideProgress();
            });
        }

        // Verifica servi√ßos
        async function checkServices() {
            // Verifica Ollama
            updateServiceStatus('ollama', 'checking');
            const ollamaOk = await KC.EmbeddingService.checkOllamaAvailability();
            updateServiceStatus('ollama', ollamaOk ? 'online' : 'offline');
            
            // Verifica Qdrant
            updateServiceStatus('qdrant', 'checking');
            const qdrantOk = await KC.QdrantService.checkConnection();
            updateServiceStatus('qdrant', qdrantOk ? 'online' : 'offline');

            // Habilita bot√£o se ambos est√£o OK
            document.getElementById('btn-process').disabled = !(ollamaOk && qdrantOk);
            
            if (!ollamaOk) {
                log('error', 'Ollama n√£o est√° dispon√≠vel. Verifique se est√° rodando em http://127.0.0.1:11434');
            }
            if (!qdrantOk) {
                log('error', 'Qdrant n√£o est√° acess√≠vel. Verifique a conex√£o com http://qdr.vcia.com.br:6333');
            }
        }

        // Atualiza status do servi√ßo
        function updateServiceStatus(service, status) {
            const indicator = document.getElementById(`${service}-status`);
            const text = document.getElementById(`${service}-text`);
            
            indicator.className = `status-indicator status-${status}`;
            text.textContent = status === 'online' ? 'Online' : 
                              status === 'offline' ? 'Offline' : 'Verificando...';
        }

        // Cria dados de teste
        function createTestData() {
            testData = [
                {
                    id: 'test-doc-1',
                    name: 'Case Ambev - Transforma√ß√£o Digital.md',
                    path: '/test/Case_Ambev.md',
                    content: `# Case Ambev: Transforma√ß√£o Digital na Ind√∫stria de Bebidas\n\n## Contexto\nA Ambev, maior cervejaria da Am√©rica Latina, enfrentava desafios significativos em 2018. Com mais de 100 marcas e opera√ß√µes em 19 pa√≠ses, a empresa precisava modernizar suas opera√ß√µes para manter a competitividade.\n\n## O Desafio\nO principal desafio era integrar toda a cadeia de suprimentos, desde a produ√ß√£o at√© a entrega final. Os sistemas legados n√£o conversavam entre si, causando:\n- Atrasos nas entregas\n- Excesso de estoque\n- Perda de vendas por falta de produto\n\n## A Solu√ß√£o\nA empresa implementou uma plataforma digital integrada que conectava:\n1. F√°bricas\n2. Centros de distribui√ß√£o\n3. Pontos de venda\n4. Consumidores finais\n\n## Resultados\n- Redu√ß√£o de 30% no tempo de entrega\n- Aumento de 25% na satisfa√ß√£o do cliente\n- Economia de R$ 50 milh√µes em log√≠stica\n\n## Li√ß√µes Aprendidas\nA transforma√ß√£o digital n√£o √© apenas sobre tecnologia, mas sobre pessoas e processos.`,
                    size: 1523,
                    lastModified: new Date('2024-03-15').toISOString(),
                    relevanceScore: 85,
                    categories: ['transforma√ß√£o-digital', 'cases'],
                    analyzed: true,
                    analysisType: 'Breakthrough T√©cnico'
                },
                {
                    id: 'test-doc-2',
                    name: 'Estrat√©gia de Inova√ß√£o 2024.txt',
                    path: '/test/Estrategia_Inovacao.txt',
                    content: `Documento Estrat√©gico - Inova√ß√£o 2024\n\nObjetivo: Estabelecer as diretrizes para o programa de inova√ß√£o corporativa.\n\n1. Foco em IA e Machine Learning\n   - Implementar IA em todos os processos cr√≠ticos\n   - Desenvolver modelos preditivos para demanda\n   - Automatizar tarefas repetitivas\n\n2. Cultura de Inova√ß√£o\n   - Programa de ideias com recompensas\n   - Hackathons trimestrais\n   - Parcerias com startups\n\n3. M√©tricas de Sucesso\n   - ROI de projetos de inova√ß√£o > 200%\n   - Tempo de implementa√ß√£o < 6 meses\n   - Engajamento de colaboradores > 70%\n\n4. Or√ßamento\n   - R$ 10 milh√µes para 2024\n   - Distribui√ß√£o: 40% IA, 30% Pessoas, 30% Infraestrutura`,
                    size: 892,
                    lastModified: new Date('2024-01-10').toISOString(),
                    relevanceScore: 92,
                    categories: ['estrat√©gia', 'inova√ß√£o'],
                    analyzed: true,
                    analysisType: 'Insight Estrat√©gico'
                },
                {
                    id: 'test-doc-3',
                    name: 'Notas de Reuni√£o - Projeto Alpha.md',
                    path: '/test/Notas_Projeto_Alpha.md',
                    content: `# Reuni√£o Projeto Alpha - 15/02/2024\n\n## Participantes\n- Jo√£o Silva (Gerente de Projeto)\n- Maria Santos (Tech Lead)\n- Pedro Oliveira (Arquiteto de Solu√ß√µes)\n\n## Decis√µes Tomadas\n\n### 1. Arquitetura\n**DECIS√ÉO CR√çTICA**: Migrar de monolito para microservi√ßos\n- Prazo: 6 meses\n- Investment: R$ 2M\n- Equipe: 15 desenvolvedores\n\n### 2. Tecnologias\n- Backend: Node.js + TypeScript\n- Frontend: React + Next.js\n- Database: PostgreSQL + Redis\n- Mensageria: RabbitMQ\n\n### 3. Pr√≥ximos Passos\n1. POC em 30 dias\n2. MVP em 90 dias\n3. Produ√ß√£o em 180 dias\n\n## Riscos Identificados\n- Resist√™ncia da equipe legada\n- Complexidade da migra√ß√£o de dados\n- Depend√™ncia de fornecedores externos`,
                    size: 756,
                    lastModified: new Date('2024-02-15').toISOString(),
                    relevanceScore: 78,
                    categories: ['projetos', 'decis√µes'],
                    analyzed: true,
                    analysisType: 'Momento Decisivo'
                }
            ];

            // Adiciona preview aos dados
            testData.forEach(doc => {
                doc.preview = KC.PreviewUtils.extractPreview(doc.content);
            });

            // Salva no AppState
            KC.AppState.set('files', testData);
            
            updateDataStatus();
            log('success', `${testData.length} arquivos de teste criados`);
        }

        // Carrega dados existentes
        function loadExistingData() {
            const files = KC.AppState.get('files') || [];
            if (files.length === 0) {
                log('error', 'Nenhum arquivo encontrado no AppState');
                return;
            }
            
            testData = files;
            updateDataStatus();
            log('success', `${files.length} arquivos carregados do AppState`);
        }

        // Limpa dados
        function clearTestData() {
            testData = null;
            KC.AppState.set('files', []);
            updateDataStatus();
            log('info', 'Dados limpos');
        }

        // Atualiza status dos dados
        function updateDataStatus() {
            const statusDiv = document.getElementById('data-status');
            if (!testData || testData.length === 0) {
                statusDiv.innerHTML = '<p>Nenhum dado carregado</p>';
                return;
            }

            // Corrige valores de relev√¢ncia se necess√°rio (converte decimal para percentual)
            testData.forEach(doc => {
                if (doc.relevanceScore && doc.relevanceScore < 1) {
                    doc.relevanceScore = doc.relevanceScore * 100;
                }
            });
            
            // Separa arquivos aprovados e arquivados
            const approved = testData.filter(f => !f.archived && f.relevanceScore >= 50);
            const archived = testData.filter(f => f.archived);
            const lowRelevance = testData.filter(f => !f.archived && f.relevanceScore < 50);

            let html = `<p><strong>${testData.length} arquivos carregados:</strong></p>`;
            
            // Arquivos aprovados
            if (approved.length > 0) {
                html += `<h4 style="color: var(--success-color);">‚úÖ Aprovados (${approved.length}):</h4><ul>`;
                approved.forEach(doc => {
                    html += `<li style="color: var(--success-color);">${doc.name} - Relev√¢ncia: ${doc.relevanceScore}% - ${doc.analysisType || 'N√£o analisado'}</li>`;
                });
                html += '</ul>';
            }
            
            // Arquivos com baixa relev√¢ncia
            if (lowRelevance.length > 0) {
                html += `<h4 style="color: var(--warning-color);">‚ö†Ô∏è Baixa Relev√¢ncia (${lowRelevance.length}):</h4><ul>`;
                lowRelevance.forEach(doc => {
                    html += `<li style="color: var(--warning-color);">${doc.name} - Relev√¢ncia: ${doc.relevanceScore}% - ${doc.analysisType || 'N√£o analisado'}</li>`;
                });
                html += '</ul>';
            }
            
            // Arquivos arquivados
            if (archived.length > 0) {
                html += `<h4 style="color: var(--danger-color);">üóÑÔ∏è Arquivados/Descartados (${archived.length}):</h4><ul>`;
                archived.forEach(doc => {
                    html += `<li style="color: var(--danger-color); text-decoration: line-through;">${doc.name} - Relev√¢ncia: ${doc.relevanceScore}% - ARQUIVADO</li>`;
                });
                html += '</ul>';
            }
            
            // Resumo
            html += `<hr><p><strong>Resumo:</strong> ${approved.length} aprovados para processamento, ${archived.length} arquivados, ${lowRelevance.length} com baixa relev√¢ncia</p>`;
            
            statusDiv.innerHTML = html;
        }

        // Executa pipeline completo
        async function runPipeline() {
            if (!testData || testData.length === 0) {
                log('error', 'Carregue dados antes de executar o pipeline');
                return;
            }

            // Verifica se h√° arquivos aprovados
            const approved = testData.filter(f => !f.archived && f.relevanceScore >= 50);
            if (approved.length === 0) {
                log('error', 'Nenhum arquivo aprovado encontrado! Arquivos devem ter relev√¢ncia >= 50% e n√£o estar arquivados.');
                return;
            }

            log('info', `Iniciando pipeline de processamento com ${approved.length} arquivos aprovados...`);
            showProgress();

            try {
                const result = await KC.RAGExportManager.processApprovedFiles({
                    batchSize: 5
                });

                if (result.success) {
                    log('success', result.message);
                    log('info', `Detalhes: ${result.results.processed} processados, ${result.results.failed} falharam, ${result.results.totalChunks} chunks criados`);
                } else {
                    log('error', result.message || result.error);
                }
            } catch (error) {
                log('error', `Erro no pipeline: ${error.message}`);
                hideProgress();
            }
        }

        // Testa consolida√ß√£o
        async function testConsolidation() {
            log('info', 'Testando consolida√ß√£o de dados...');
            
            try {
                const data = await KC.RAGExportManager.consolidateData();
                log('success', `Consolidados ${data.documents.length} documentos`);
                log('info', `Total de chunks: ${data.documents.reduce((acc, doc) => acc + doc.chunks.length, 0)}`);
                console.log('Dados consolidados:', data);
            } catch (error) {
                log('error', `Erro na consolida√ß√£o: ${error.message}`);
            }
        }

        // Testa chunking
        function testChunking() {
            if (!testData || testData.length === 0) {
                log('error', 'Carregue dados primeiro');
                return;
            }

            log('info', 'Testando chunking...');
            const doc = testData[0];
            const chunks = KC.ChunkingUtils.getSemanticChunks(doc.content);
            
            log('success', `${chunks.length} chunks gerados para "${doc.name}"`);
            chunks.forEach((chunk, i) => {
                log('info', `Chunk ${i + 1}: ${chunk.content.substring(0, 50)}...`);
            });
        }

        // Testa embeddings
        async function testEmbedding() {
            log('info', 'Testando gera√ß√£o de embeddings...');
            
            try {
                const text = "Este √© um teste de gera√ß√£o de embeddings para busca sem√¢ntica";
                const embedding = await KC.EmbeddingService.generateEmbedding(text);
                
                if (embedding && embedding.length > 0) {
                    log('success', `Embedding gerado com ${embedding.length} dimens√µes`);
                    log('info', `Primeiros 5 valores: [${embedding.slice(0, 5).join(', ')}...]`);
                } else {
                    log('error', 'Embedding vazio ou inv√°lido');
                }
            } catch (error) {
                log('error', `Erro ao gerar embedding: ${error.message}`);
            }
        }

        // Testa inser√ß√£o no Qdrant
        async function testQdrantInsert() {
            log('info', 'Testando inser√ß√£o no Qdrant...');
            
            try {
                const testPoint = {
                    id: 'test-' + Date.now(),
                    vector: await KC.EmbeddingService.generateEmbedding('Teste de inser√ß√£o no Qdrant'),
                    payload: {
                        content: 'Teste de inser√ß√£o no Qdrant',
                        timestamp: new Date().toISOString()
                    }
                };

                const result = await KC.QdrantService.insertBatch([testPoint]);
                
                if (result.success) {
                    log('success', 'Ponto inserido com sucesso no Qdrant');
                } else {
                    log('error', `Erro ao inserir: ${result.error}`);
                }
            } catch (error) {
                log('error', `Erro ao testar Qdrant: ${error.message}`);
            }
        }

        // Busca sem√¢ntica
        async function searchSemantic() {
            const query = document.getElementById('search-query').value;
            if (!query) {
                log('error', 'Digite algo para buscar');
                return;
            }

            log('info', `Buscando por: "${query}"...`);
            
            try {
                const results = await KC.QdrantService.searchByText(query, 5);
                
                const resultsDiv = document.getElementById('search-results');
                if (results && results.length > 0) {
                    let html = `<p><strong>Encontrados ${results.length} resultados:</strong></p>`;
                    results.forEach((result, i) => {
                        html += `
                            <div class="sample-data">
                                <strong>${i + 1}. Score: ${result.score.toFixed(3)}</strong><br>
                                <strong>Arquivo:</strong> ${result.payload.fileName || 'N/A'}<br>
                                <strong>Conte√∫do:</strong> ${result.payload.content.substring(0, 200)}...
                            </div>
                        `;
                    });
                    resultsDiv.innerHTML = html;
                } else {
                    resultsDiv.innerHTML = '<p>Nenhum resultado encontrado</p>';
                }
            } catch (error) {
                log('error', `Erro na busca: ${error.message}`);
            }
        }

        // Fun√ß√µes auxiliares
        function log(type, message) {
            const output = document.getElementById('pipeline-output');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `<strong>[${new Date().toLocaleTimeString()}]</strong> ${message}`;
            output.appendChild(entry);
            output.scrollTop = output.scrollHeight;
        }

        function showProgress() {
            document.getElementById('pipeline-progress').style.display = 'block';
            updateProgress(0, '0/0');
        }

        function hideProgress() {
            document.getElementById('pipeline-progress').style.display = 'none';
        }

        function updateProgress(percentage, text) {
            document.getElementById('progress-fill').style.width = percentage + '%';
            document.getElementById('progress-text').textContent = `${percentage}% - ${text}`;
        }
    </script>
</body>
</html>