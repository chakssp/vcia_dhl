<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste Integra√ß√£o Schema.org</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #1e88e5;
            padding-bottom: 10px;
        }
        .section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-controls button {
            background: #1e88e5;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        .test-controls button:hover {
            background: #1976d2;
        }
        .test-controls button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.success {
            background: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #4caf50;
        }
        .status.error {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #f44336;
        }
        .status.info {
            background: #e3f2fd;
            color: #1565c0;
            border: 1px solid #2196f3;
        }
        .results {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            margin-top: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .metric {
            display: inline-block;
            padding: 5px 10px;
            margin: 5px;
            background: #e3f2fd;
            border-radius: 4px;
        }
        .cache-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .cache-stat {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .cache-stat h4 {
            margin: 0 0 5px 0;
            color: #666;
        }
        .cache-stat .value {
            font-size: 24px;
            font-weight: bold;
            color: #1e88e5;
        }
        pre {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .json-ld {
            background: #263238;
            color: #aed581;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>üß™ Teste de Integra√ß√£o Schema.org</h1>
    
    <div class="section">
        <h2>Status dos Componentes</h2>
        <div id="component-status"></div>
    </div>

    <div class="section">
        <h2>Testes de Mapeamento</h2>
        <div class="test-controls">
            <button onclick="testBasicMapping()">1. Teste B√°sico</button>
            <button onclick="testWithCache()">2. Teste com Cache</button>
            <button onclick="testAsyncMapping()">3. Teste Ass√≠ncrono</button>
            <button onclick="testBatchMapping()">4. Teste em Lote</button>
            <button onclick="testCachePerformance()">5. Performance do Cache</button>
            <button onclick="clearCache()">üóëÔ∏è Limpar Cache</button>
        </div>
        <div id="test-results"></div>
    </div>

    <div class="section">
        <h2>Estat√≠sticas de Cache</h2>
        <div class="cache-stats" id="cache-stats">
            <div class="cache-stat">
                <h4>Hit Rate L1</h4>
                <div class="value" id="l1-hit-rate">0%</div>
            </div>
            <div class="cache-stat">
                <h4>Hit Rate L2</h4>
                <div class="value" id="l2-hit-rate">0%</div>
            </div>
            <div class="cache-stat">
                <h4>Lat√™ncia M√©dia</h4>
                <div class="value" id="avg-latency">0ms</div>
            </div>
            <div class="cache-stat">
                <h4>Total Cached</h4>
                <div class="value" id="total-cached">0</div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Exemplo de Sa√≠da Schema.org</h2>
        <div class="json-ld" id="schema-output"></div>
    </div>

    <!-- Carregar scripts necess√°rios -->
    <script src="js/core/EventBus.js"></script>
    <script src="js/core/AppState.js"></script>
    <script src="js/utils/Logger.js"></script>
    <script src="js/services/CacheService.js"></script>
    <script src="js/managers/SchemaOrgMapper.js"></script>

    <script>
        // Verificar componentes
        async function checkComponents() {
            const status = document.getElementById('component-status');
            const components = [
                { name: 'EventBus', exists: typeof KC?.EventBus !== 'undefined' },
                { name: 'Logger', exists: typeof KC?.Logger !== 'undefined' },
                { name: 'CacheService', exists: typeof KC?.CacheService !== 'undefined' },
                { name: 'SchemaOrgMapper', exists: typeof KC?.SchemaOrgMapper !== 'undefined' }
            ];

            let html = '';
            for (const comp of components) {
                html += `<div class="status ${comp.exists ? 'success' : 'error'}">
                    ${comp.exists ? '‚úÖ' : '‚ùå'} ${comp.name}
                </div>`;
            }
            status.innerHTML = html;

            // Inicializar CacheService se existir
            if (KC?.CacheService) {
                try {
                    await KC.CacheService.initialize();
                    status.innerHTML += '<div class="status success">‚úÖ CacheService inicializado</div>';
                } catch (error) {
                    status.innerHTML += '<div class="status error">‚ùå Erro ao inicializar CacheService: ' + error.message + '</div>';
                }
            }
        }

        // Arquivo de teste
        const testFile = {
            id: 'test-123',
            name: 'decisao-estrategica-2024.md',
            path: '/docs/decisoes/decisao-estrategica-2024.md',
            content: 'Ap√≥s an√°lise detalhada do mercado, decidimos expandir para o segmento B2B...',
            preview: 'Decis√£o estrat√©gica sobre expans√£o B2B',
            analysisType: 'Momento Decisivo',
            confidence: 0.85,
            categories: ['Estrat√©gia', 'B2B', 'Expans√£o'],
            relevanceScore: 95,
            size: 4567,
            modifiedDate: new Date('2024-03-15')
        };

        // Teste 1: Mapeamento b√°sico
        async function testBasicMapping() {
            const results = document.getElementById('test-results');
            results.innerHTML = '<div class="status info">üîÑ Testando mapeamento b√°sico...</div>';

            try {
                const start = performance.now();
                const schema = await KC.SchemaOrgMapper.mapToSchema(testFile);
                const duration = performance.now() - start;

                results.innerHTML = `
                    <div class="status success">‚úÖ Mapeamento b√°sico conclu√≠do</div>
                    <div class="metric">Tempo: ${duration.toFixed(2)}ms</div>
                    <div class="metric">Tipo: ${schema['@type']}</div>
                    <div class="results">${JSON.stringify(schema, null, 2)}</div>
                `;

                // Atualizar exemplo
                document.getElementById('schema-output').textContent = JSON.stringify(schema, null, 2);
            } catch (error) {
                results.innerHTML = `<div class="status error">‚ùå Erro: ${error.message}</div>`;
            }
        }

        // Teste 2: Com cache
        async function testWithCache() {
            const results = document.getElementById('test-results');
            results.innerHTML = '<div class="status info">üîÑ Testando com cache...</div>';

            try {
                // Primeira chamada (cache miss)
                const start1 = performance.now();
                const schema1 = await KC.SchemaOrgMapper.mapToSchema(testFile);
                const duration1 = performance.now() - start1;

                // Segunda chamada (cache hit)
                const start2 = performance.now();
                const schema2 = await KC.SchemaOrgMapper.mapToSchema(testFile);
                const duration2 = performance.now() - start2;

                const speedup = ((duration1 - duration2) / duration1 * 100).toFixed(1);

                results.innerHTML = `
                    <div class="status success">‚úÖ Teste de cache conclu√≠do</div>
                    <div class="metric">Cache Miss: ${duration1.toFixed(2)}ms</div>
                    <div class="metric">Cache Hit: ${duration2.toFixed(2)}ms</div>
                    <div class="metric">Speedup: ${speedup}%</div>
                    <div class="results">Cache funcionando! Segunda chamada ${speedup}% mais r√°pida</div>
                `;

                updateCacheStats();
            } catch (error) {
                results.innerHTML = `<div class="status error">‚ùå Erro: ${error.message}</div>`;
            }
        }

        // Teste 3: Ass√≠ncrono
        async function testAsyncMapping() {
            const results = document.getElementById('test-results');
            results.innerHTML = '<div class="status info">üîÑ Testando opera√ß√µes ass√≠ncronas...</div>';

            try {
                // Criar m√∫ltiplos arquivos
                const files = Array(5).fill(null).map((_, i) => ({
                    ...testFile,
                    id: `async-test-${i}`,
                    name: `arquivo-${i}.md`,
                    analysisType: ['Momento Decisivo', 'Insight T√©cnico', 'Evolu√ß√£o Conceitual'][i % 3]
                }));

                // Mapear todos em paralelo
                const start = performance.now();
                const schemas = await Promise.all(files.map(f => KC.SchemaOrgMapper.mapToSchema(f)));
                const duration = performance.now() - start;

                results.innerHTML = `
                    <div class="status success">‚úÖ Mapeamento ass√≠ncrono conclu√≠do</div>
                    <div class="metric">Total: ${schemas.length} arquivos</div>
                    <div class="metric">Tempo total: ${duration.toFixed(2)}ms</div>
                    <div class="metric">M√©dia: ${(duration / schemas.length).toFixed(2)}ms/arquivo</div>
                    <div class="results">${schemas.map(s => s['@type']).join(', ')}</div>
                `;

                updateCacheStats();
            } catch (error) {
                results.innerHTML = `<div class="status error">‚ùå Erro: ${error.message}</div>`;
            }
        }

        // Teste 4: Em lote
        async function testBatchMapping() {
            const results = document.getElementById('test-results');
            results.innerHTML = '<div class="status info">üîÑ Testando mapeamento em lote...</div>';

            try {
                const batchSize = 20;
                const files = Array(batchSize).fill(null).map((_, i) => ({
                    ...testFile,
                    id: `batch-${i}`,
                    name: `batch-file-${i}.md`,
                    confidence: 0.5 + (Math.random() * 0.5)
                }));

                const start = performance.now();
                const results = [];
                
                for (const file of files) {
                    const schema = await KC.SchemaOrgMapper.mapToSchema(file);
                    results.push(schema);
                }
                
                const duration = performance.now() - start;

                const avgConfidence = files.reduce((sum, f) => sum + f.confidence, 0) / files.length;

                document.getElementById('test-results').innerHTML = `
                    <div class="status success">‚úÖ Lote processado</div>
                    <div class="metric">Total: ${batchSize} arquivos</div>
                    <div class="metric">Tempo: ${duration.toFixed(2)}ms</div>
                    <div class="metric">Confian√ßa m√©dia: ${(avgConfidence * 100).toFixed(1)}%</div>
                    <div class="results">Todos os arquivos mapeados com sucesso!</div>
                `;

                updateCacheStats();
            } catch (error) {
                document.getElementById('test-results').innerHTML = `<div class="status error">‚ùå Erro: ${error.message}</div>`;
            }
        }

        // Teste 5: Performance do cache
        async function testCachePerformance() {
            const results = document.getElementById('test-results');
            results.innerHTML = '<div class="status info">üîÑ Testando performance do cache...</div>';

            try {
                const iterations = 100;
                const timings = { miss: [], hit: [] };

                // Cache misses
                for (let i = 0; i < iterations; i++) {
                    const file = { ...testFile, id: `perf-miss-${i}` };
                    const start = performance.now();
                    await KC.SchemaOrgMapper.mapToSchema(file);
                    timings.miss.push(performance.now() - start);
                }

                // Cache hits
                for (let i = 0; i < iterations; i++) {
                    const file = { ...testFile, id: `perf-miss-${i}` }; // Mesmo ID
                    const start = performance.now();
                    await KC.SchemaOrgMapper.mapToSchema(file);
                    timings.hit.push(performance.now() - start);
                }

                const avgMiss = timings.miss.reduce((a, b) => a + b) / timings.miss.length;
                const avgHit = timings.hit.reduce((a, b) => a + b) / timings.hit.length;
                const improvement = ((avgMiss - avgHit) / avgMiss * 100).toFixed(1);

                results.innerHTML = `
                    <div class="status success">‚úÖ Teste de performance conclu√≠do</div>
                    <div class="metric">Itera√ß√µes: ${iterations}</div>
                    <div class="metric">Avg Miss: ${avgMiss.toFixed(2)}ms</div>
                    <div class="metric">Avg Hit: ${avgHit.toFixed(2)}ms</div>
                    <div class="metric">Melhoria: ${improvement}%</div>
                    <div class="results">Cache reduz lat√™ncia em ${improvement}%!</div>
                `;

                updateCacheStats();
            } catch (error) {
                results.innerHTML = `<div class="status error">‚ùå Erro: ${error.message}</div>`;
            }
        }

        // Limpar cache
        async function clearCache() {
            if (KC?.CacheService) {
                await KC.CacheService.clear();
                document.getElementById('test-results').innerHTML = 
                    '<div class="status success">‚úÖ Cache limpo com sucesso</div>';
                updateCacheStats();
            }
        }

        // Atualizar estat√≠sticas
        async function updateCacheStats() {
            if (!KC?.CacheService) return;

            const stats = await KC.CacheService.getStats();
            
            document.getElementById('l1-hit-rate').textContent = 
                stats.l1HitRate ? `${(stats.l1HitRate * 100).toFixed(1)}%` : '0%';
            
            document.getElementById('l2-hit-rate').textContent = 
                stats.l2HitRate ? `${(stats.l2HitRate * 100).toFixed(1)}%` : '0%';
            
            document.getElementById('avg-latency').textContent = 
                stats.avgLatency ? `${stats.avgLatency.toFixed(1)}ms` : '0ms';
            
            document.getElementById('total-cached').textContent = 
                stats.totalCached || '0';
        }

        // Inicializar
        window.addEventListener('load', () => {
            checkComponents();
            
            // Atualizar stats a cada 2 segundos
            setInterval(updateCacheStats, 2000);
        });
    </script>
</body>
</html>