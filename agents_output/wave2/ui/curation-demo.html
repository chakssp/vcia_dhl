<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Confidence Curation Panel - Demo</title>
    
    <!-- KC CSS Dependencies -->
    <link rel="stylesheet" href="../../../css/utils/variables.css">
    <link rel="stylesheet" href="../../../css/main.css">
    
    <!-- Curation Panel CSS -->
    <link rel="stylesheet" href="curation-panel.css">
    
    <style>
        /* Demo-specific styles */
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        #demo-container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        .demo-notice {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid #3b82f6;
            border-radius: 8px;
            padding: 12px 24px;
            color: #3b82f6;
            font-size: 14px;
            z-index: 1000;
            display: none;
        }
        
        .demo-notice.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                transform: translate(-50%, -20px);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <!-- Demo Container -->
    <div id="demo-container"></div>
    
    <!-- Demo Notice -->
    <div class="demo-notice" id="demo-notice"></div>
    
    <!-- Mock KC Setup -->
    <script>
        // Create mock KC namespace with essential components
        window.KC = {
            // Mock EventBus
            EventBus: {
                _handlers: new Map(),
                on(event, handler) {
                    if (!this._handlers.has(event)) {
                        this._handlers.set(event, []);
                    }
                    this._handlers.get(event).push(handler);
                },
                emit(event, data) {
                    const handlers = this._handlers.get(event);
                    if (handlers) {
                        handlers.forEach(h => h(data));
                    }
                },
                off(event, handler) {
                    const handlers = this._handlers.get(event);
                    if (handlers) {
                        const idx = handlers.indexOf(handler);
                        if (idx > -1) handlers.splice(idx, 1);
                    }
                }
            },
            
            // Mock AppState
            AppState: {
                _state: new Map(),
                get(key) {
                    return this._state.get(key);
                },
                set(key, value) {
                    this._state.set(key, value);
                    KC.EventBus.emit('state:changed', { key, value });
                }
            }
        };
        
        // Generate demo data
        function generateDemoFiles() {
            const files = [];
            const fileNames = [
                'projeto-vanguarda-estrategica.md',
                'analise-mercado-2024.docx',
                'relatorio-trimestral-q4.pdf',
                'insights-inovacao-produto.txt',
                'estrategia-digital-roadmap.md',
                'pesquisa-usuario-dezembro.doc',
                'plano-acao-2025.md',
                'retrospectiva-sprint-15.txt',
                'proposta-arquitetura-ml.md',
                'benchmarking-competidores.xlsx'
            ];
            
            const categories = ['technical', 'strategic', 'conceptual', 'development'];
            
            for (let i = 0; i < fileNames.length; i++) {
                const confidence = Math.random() * 0.6 + 0.3; // 0.3 to 0.9
                files.push({
                    id: `file_${i + 1}`,
                    name: fileNames[i],
                    path: `/documents/${fileNames[i]}`,
                    type: fileNames[i].split('.').pop(),
                    size: Math.floor(Math.random() * 1000000) + 50000,
                    createdAt: new Date(Date.now() - Math.random() * 90 * 24 * 60 * 60 * 1000),
                    modifiedAt: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000),
                    lastAnalyzed: Math.random() > 0.5 ? new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000) : null,
                    analysisCount: Math.floor(Math.random() * 5),
                    categories: [categories[Math.floor(Math.random() * categories.length)]],
                    confidence: {
                        overall: confidence,
                        dimensions: {
                            semantic: Math.random() * 0.3 + 0.6,
                            categorical: Math.random() * 0.3 + 0.5,
                            structural: Math.random() * 0.3 + 0.6,
                            temporal: Math.random() * 0.3 + 0.4
                        },
                        convergencePrediction: {
                            willConverge: confidence > 0.6,
                            isConverged: confidence > 0.85,
                            estimatedIterations: Math.ceil(Math.random() * 5) + 1,
                            confidence: 0.8 + Math.random() * 0.2
                        }
                    },
                    content: `# ${fileNames[i]}\n\nConteúdo de demonstração para análise de confiança ML...`
                });
            }
            
            return files;
        }
        
        // Set demo data in AppState
        KC.AppState.set('files', generateDemoFiles());
    </script>
    
    <!-- Wave 1 Components (Mocked for demo) -->
    <script>
        // Mock VersionedAppState
        window.VersionedAppState = class {
            constructor(fileId) {
                this.fileId = fileId;
                this.versions = new Map();
                this.versionOrder = [];
                this.currentVersionIndex = -1;
            }
            
            createSnapshot(state, metadata) {
                const versionId = `v_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const version = {
                    versionId,
                    timestamp: Date.now(),
                    state,
                    metadata,
                    type: 'full'
                };
                this.versions.set(versionId, version);
                this.versionOrder.push(versionId);
                this.currentVersionIndex = this.versionOrder.length - 1;
                return versionId;
            }
            
            getAllVersions() {
                return this.versionOrder.map((id, index) => ({
                    versionId: id,
                    timestamp: this.versions.get(id).timestamp,
                    metadata: this.versions.get(id).metadata,
                    isCurrent: index === this.currentVersionIndex,
                    type: this.versions.get(id).type
                }));
            }
            
            getVersion(versionId) {
                return this.versions.get(versionId);
            }
            
            restoreVersion(versionId) {
                const version = this.versions.get(versionId);
                if (version) {
                    this.currentVersionIndex = this.versionOrder.indexOf(versionId);
                    return version.state;
                }
                return null;
            }
            
            compareVersions(versionIdA, versionIdB) {
                return {
                    additions: [{ path: 'confidence.overall', value: 0.85 }],
                    modifications: [{ path: 'analysisCount', oldValue: 2, newValue: 3 }],
                    deletions: [],
                    summary: '2 changes: 1 additions, 1 modifications, 0 deletions',
                    metadata: {
                        fromVersion: versionIdA,
                        toVersion: versionIdB,
                        totalChanges: 2
                    }
                };
            }
        };
        
        // Mock ConfidenceTracker
        window.KnowledgeConsolidator = window.KnowledgeConsolidator || {};
        window.KnowledgeConsolidator.ConfidenceTracker = class {
            constructor(eventBus, appState) {
                this.eventBus = eventBus;
                this.appState = appState;
                this.trackedFiles = new Map();
            }
            
            startTracking(fileId, data) {
                this.trackedFiles.set(fileId, {
                    fileId,
                    history: [],
                    startedAt: new Date(),
                    lastUpdated: new Date(),
                    metadata: data
                });
            }
            
            updateMetrics(fileId, metrics) {
                const entry = this.trackedFiles.get(fileId);
                if (entry) {
                    entry.history.push({ metrics, timestamp: new Date() });
                    entry.lastUpdated = new Date();
                    this.eventBus.emit('confidence:metrics:updated', { fileId, metrics });
                }
            }
            
            getConvergenceHistory(fileId) {
                const entry = this.trackedFiles.get(fileId);
                return entry ? entry.history : [];
            }
            
            needsReanalysis(fileId) {
                const entry = this.trackedFiles.get(fileId);
                if (!entry || entry.history.length === 0) return true;
                const lastMetrics = entry.history[entry.history.length - 1].metrics;
                return lastMetrics.overall < 0.85;
            }
        };
        
        // Mock ConfidenceCalculator
        window.ConfidenceCalculator = class {
            constructor() {
                this.weights = {
                    semantic: 0.4,
                    categorical: 0.2,
                    structural: 0.2,
                    temporal: 0.2
                };
                this.config = {
                    minConfidence: 0.65,
                    targetConfidence: 0.85,
                    enableAdaptiveWeights: true
                };
            }
            
            calculate(analysisData) {
                // Simulate calculation with slight improvement
                const baseConfidence = analysisData.previousConfidence || 0.5;
                const improvement = Math.random() * 0.1 + 0.05;
                const newConfidence = Math.min(0.95, baseConfidence + improvement);
                
                return {
                    fileId: analysisData.fileId,
                    overall: newConfidence,
                    dimensions: {
                        semantic: Math.random() * 0.3 + 0.6,
                        categorical: Math.random() * 0.3 + 0.5,
                        structural: Math.random() * 0.3 + 0.6,
                        temporal: Math.random() * 0.3 + 0.4
                    },
                    convergencePrediction: {
                        willConverge: newConfidence > 0.6,
                        isConverged: newConfidence > 0.85,
                        estimatedIterations: Math.ceil((0.85 - newConfidence) / 0.1),
                        confidence: 0.8 + Math.random() * 0.2
                    },
                    calculatedAt: new Date(),
                    algorithm: 'weighted_ensemble',
                    weights: this.weights
                };
            }
            
            getConfig() {
                return { ...this.config };
            }
            
            getWeights() {
                return { ...this.weights };
            }
            
            updateConfig(config) {
                this.config = { ...this.config, ...config };
            }
            
            optimizeWeights(feedbackData) {
                // Simulate weight optimization
                console.log('Optimizing weights with feedback:', feedbackData);
                // Slightly adjust weights
                Object.keys(this.weights).forEach(key => {
                    this.weights[key] += (Math.random() - 0.5) * 0.1;
                });
                // Normalize
                const sum = Object.values(this.weights).reduce((a, b) => a + b, 0);
                Object.keys(this.weights).forEach(key => {
                    this.weights[key] /= sum;
                });
            }
        };
    </script>
    
    <!-- Load UI Components -->
    <script src="FileCard.js"></script>
    <script src="ConfidenceVisualizer.js"></script>
    <script src="VersionTimeline.js"></script>
    <script src="MLConfigPanel.js"></script>
    <script src="CurationPanel.js"></script>
    
    <!-- Initialize Demo -->
    <script>
        // Show demo notice
        function showNotice(message, duration = 3000) {
            const notice = document.getElementById('demo-notice');
            notice.textContent = message;
            notice.classList.add('show');
            setTimeout(() => {
                notice.classList.remove('show');
            }, duration);
        }
        
        // Initialize CurationPanel
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Create CurationPanel instance
                const curationPanel = new CurationPanel('#demo-container');
                
                // Add some demo interactions
                KC.EventBus.on('file:analyzed', (data) => {
                    showNotice(`Arquivo analisado: ${data.fileId} - Confiança: ${Math.round(data.metrics.overall * 100)}%`);
                });
                
                KC.EventBus.on('confidence:converged', (data) => {
                    showNotice(`Arquivo convergiu! Confiança final: ${Math.round(data.finalMetrics.overall * 100)}%`, 5000);
                });
                
                KC.EventBus.on('appstate:snapshot:created', (data) => {
                    showNotice(`Snapshot criado para arquivo ${data.fileId}`);
                });
                
                // Show welcome message
                setTimeout(() => {
                    showNotice('Bem-vindo ao ML Confidence Curation Panel! Clique em "Analisar" para testar.', 5000);
                }, 1000);
                
                console.log('CurationPanel initialized successfully!');
                
            } catch (error) {
                console.error('Error initializing CurationPanel:', error);
                showNotice('Erro ao inicializar o painel. Verifique o console.', 5000);
            }
        });
        
        // Add keyboard shortcuts for demo
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + R: Refresh data
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                KC.AppState.set('files', generateDemoFiles());
                showNotice('Dados atualizados!');
            }
            
            // Ctrl/Cmd + D: Toggle dark mode
            if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                e.preventDefault();
                document.body.dataset.theme = document.body.dataset.theme === 'dark' ? 'light' : 'dark';
                showNotice(`Tema ${document.body.dataset.theme === 'dark' ? 'escuro' : 'claro'} ativado`);
            }
        });
    </script>
</body>
</html>