<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Interativo de Grafo - Knowledge Consolidator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.6/dist/vis-network.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0F172A 0%, #1E293B 100%);
            min-height: 100vh;
            display: flex;
            color: #F1F5F9;
        }
        
        /* Painel Lateral Esquerdo - Seleção de Dados */
        .data-panel {
            width: 350px;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(59, 130, 246, 0.3);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            padding: 20px;
            background: rgba(30, 41, 59, 0.8);
            border-bottom: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .panel-header h2 {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #F1F5F9;
        }
        
        .panel-header p {
            font-size: 0.85rem;
            color: #94A3B8;
        }
        
        /* Seções de Dados */
        .data-section {
            padding: 15px;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }
        
        .section-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }
        
        .section-title h3 {
            font-size: 1rem;
            color: #3B82F6;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-title .toggle {
            color: #64748B;
            transition: transform 0.3s;
        }
        
        .section-title.collapsed .toggle {
            transform: rotate(-90deg);
        }
        
        .section-content {
            max-height: 400px;
            overflow-y: auto;
            transition: max-height 0.3s ease;
        }
        
        .section-content.collapsed {
            max-height: 0;
            overflow: hidden;
        }
        
        /* Items Selecionáveis */
        .selectable-item {
            background: rgba(51, 65, 85, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: move;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .selectable-item:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: #3B82F6;
            transform: translateX(5px);
        }
        
        .selectable-item.selected {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3B82F6;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.4);
        }
        
        .selectable-item.dragging {
            opacity: 0.5;
        }
        
        .item-checkbox {
            width: 18px;
            height: 18px;
            accent-color: #3B82F6;
        }
        
        .item-info {
            flex: 1;
        }
        
        .item-name {
            font-weight: 600;
            color: #F1F5F9;
            font-size: 0.9rem;
        }
        
        .item-meta {
            font-size: 0.75rem;
            color: #94A3B8;
            margin-top: 2px;
        }
        
        .item-badge {
            background: rgba(59, 130, 246, 0.2);
            color: #3B82F6;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        /* Área Central - Visualização */
        .visualization-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* CORREÇÃO CRÍTICA - Canvas Container */
        #graph-container {
            flex: 1;
            height: calc(100vh - 80px);
            max-height: calc(100vh - 80px);
            overflow: hidden;
            position: relative;
        }
        
        #mynetwork {
            width: 100% !important;
            height: 100% !important;
            max-height: 100% !important;
            overflow: hidden !important;
        }
        
        .vis-network {
            width: 100% !important;
            height: 100% !important;
            max-height: 100% !important;
            overflow: hidden !important;
        }
        
        .vis-network canvas {
            max-height: 100% !important;
            width: 100% !important;
        }
        
        .toolbar {
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }
        
        .toolbar-section {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(51, 65, 85, 0.8);
            color: #CBD5E1;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(59, 130, 246, 0.4);
            background: rgba(59, 130, 246, 0.2);
            border-color: #3B82F6;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #3B82F6, #2563EB);
            color: white;
            border: none;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #10B981, #059669);
            color: white;
            border: none;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #EF4444, #DC2626);
            color: white;
            border: none;
        }
        
        #graph-container {
            flex: 1;
            position: relative;
            background: rgba(30, 41, 59, 0.3);
        }
        
        #mynetwork {
            width: 100%;
            height: 100%;
        }
        
        /* Painel Direito - Configurações */
        .config-panel {
            width: 300px;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(59, 130, 246, 0.3);
            overflow-y: auto;
        }
        
        .config-section {
            padding: 15px;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }
        
        .config-section h4 {
            font-size: 0.9rem;
            color: #3B82F6;
            margin-bottom: 10px;
        }
        
        .config-option {
            margin-bottom: 12px;
        }
        
        .config-option label {
            display: block;
            font-size: 0.8rem;
            color: #94A3B8;
            margin-bottom: 5px;
        }
        
        .config-option select,
        .config-option input {
            width: 100%;
            padding: 6px 10px;
            background: rgba(51, 65, 85, 0.5);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 4px;
            color: #F1F5F9;
            font-size: 0.85rem;
        }
        
        .config-option input[type="range"] {
            padding: 0;
        }
        
        .range-value {
            text-align: center;
            color: #3B82F6;
            font-size: 0.8rem;
            margin-top: 3px;
        }
        
        /* Lista de Correlações */
        .correlation-list {
            padding: 15px;
        }
        
        .correlation-item {
            background: rgba(51, 65, 85, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .correlation-item i {
            color: #3B82F6;
        }
        
        .correlation-info {
            flex: 1;
        }
        
        .correlation-from {
            font-size: 0.85rem;
            color: #F1F5F9;
        }
        
        .correlation-to {
            font-size: 0.85rem;
            color: #94A3B8;
        }
        
        .correlation-strength {
            font-size: 0.75rem;
            color: #10B981;
            margin-top: 2px;
        }
        
        .remove-correlation {
            color: #EF4444;
            cursor: pointer;
            transition: transform 0.3s;
        }
        
        .remove-correlation:hover {
            transform: scale(1.2);
        }
        
        /* Modal de Correlação */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.show {
            display: flex;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1E293B, #334155);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 30px;
            width: 500px;
            max-width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .modal-header {
            margin-bottom: 20px;
        }
        
        .modal-header h3 {
            font-size: 1.3rem;
            color: #F1F5F9;
        }
        
        .modal-body {
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            font-size: 0.9rem;
            color: #94A3B8;
            margin-bottom: 5px;
        }
        
        .form-group select,
        .form-group input {
            width: 100%;
            padding: 10px;
            background: rgba(51, 65, 85, 0.5);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            color: #F1F5F9;
            font-size: 0.9rem;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        /* Área de Drop */
        .drop-zone {
            border: 2px dashed rgba(59, 130, 246, 0.5);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            color: #64748B;
            transition: all 0.3s;
            margin-top: 10px;
        }
        
        .drop-zone.active {
            background: rgba(59, 130, 246, 0.1);
            border-color: #3B82F6;
            color: #3B82F6;
        }
        
        /* Loading */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        .loading i {
            font-size: 3rem;
            color: #3B82F6;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #3B82F6, #2563EB);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.5);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
            z-index: 2000;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .toast.success {
            background: linear-gradient(135deg, #10B981, #059669);
        }
        
        .toast.error {
            background: linear-gradient(135deg, #EF4444, #DC2626);
        }
    </style>
</head>
<body>
    <!-- Painel Lateral Esquerdo - Seleção de Dados -->
    <div class="data-panel">
        <div class="panel-header">
            <h2><i class="fas fa-database"></i> Seleção de Dados</h2>
            <p>Selecione e ordene os elementos para criar correlações no grafo</p>
        </div>
        
        <!-- Categorias -->
        <div class="data-section">
            <div class="section-title" onclick="toggleSection(this)">
                <h3><i class="fas fa-folder"></i> Categorias</h3>
                <i class="fas fa-chevron-down toggle"></i>
            </div>
            <div class="section-content" id="categories-list">
                <!-- Categorias serão carregadas aqui -->
            </div>
        </div>
        
        <!-- Arquivos -->
        <div class="data-section">
            <div class="section-title" onclick="toggleSection(this)">
                <h3><i class="fas fa-file"></i> Arquivos</h3>
                <i class="fas fa-chevron-down toggle"></i>
            </div>
            <div class="section-content" id="files-list">
                <!-- Arquivos serão carregados aqui -->
            </div>
        </div>
        
        <!-- Entidades -->
        <div class="data-section">
            <div class="section-title" onclick="toggleSection(this)">
                <h3><i class="fas fa-users"></i> Entidades</h3>
                <i class="fas fa-chevron-down toggle"></i>
            </div>
            <div class="section-content" id="entities-list">
                <!-- Entidades serão carregadas aqui -->
            </div>
        </div>
        
        <!-- Área de Drop para Ordenação -->
        <div class="data-section">
            <h3 style="color: #3B82F6; font-size: 1rem; margin-bottom: 10px;">
                <i class="fas fa-sort"></i> Ordem de Prioridade
            </h3>
            <div class="drop-zone" id="priority-zone">
                <i class="fas fa-arrow-down"></i> Arraste itens aqui para definir prioridade
            </div>
            <div id="priority-list" style="margin-top: 10px;">
                <!-- Items ordenados aparecerão aqui -->
            </div>
        </div>
    </div>
    
    <!-- Área Central - Visualização -->
    <div class="visualization-area">
        <div class="toolbar">
            <div class="toolbar-section">
                <button class="btn btn-primary" onclick="generateGraph()">
                    <i class="fas fa-project-diagram"></i> Gerar Grafo
                </button>
                <button class="btn btn-success" onclick="showQdrantConfigModal()">
                    <i class="fas fa-database"></i> Configurar Qdrant
                </button>
                <button class="btn" onclick="clearGraph()">
                    <i class="fas fa-eraser"></i> Limpar
                </button>
                <button class="btn" onclick="autoLayout()">
                    <i class="fas fa-magic"></i> Auto Layout
                </button>
            </div>
            
            <div class="toolbar-section">
                <button class="btn" onclick="showCorrelationModal()">
                    <i class="fas fa-link"></i> Nova Correlação
                </button>
                <button class="btn btn-success" onclick="exportGraph()">
                    <i class="fas fa-download"></i> Exportar
                </button>
                <button class="btn" onclick="importData()">
                    <i class="fas fa-upload"></i> Importar
                </button>
                <div id="qdrant-status" style="display: flex; align-items: center; gap: 8px; margin-left: 15px;">
                    <i class="fas fa-circle" style="color: #94A3B8; font-size: 8px;"></i>
                    <span style="font-size: 0.8rem; color: #94A3B8;">Conectando...</span>
                </div>
            </div>
        </div>
        
        <div id="graph-container">
            <div id="mynetwork"></div>
            <div class="loading" id="loading" style="display: none;">
                <i class="fas fa-spinner"></i>
                <p style="margin-top: 10px; color: #94A3B8;">Processando...</p>
            </div>
        </div>
    </div>
    
    <!-- Painel Direito - Configurações -->
    <div class="config-panel">
        <div class="panel-header">
            <h2><i class="fas fa-cog"></i> Configurações</h2>
        </div>
        
        <!-- Layout -->
        <div class="config-section">
            <h4><i class="fas fa-th"></i> Layout</h4>
            <div class="config-option">
                <label>Tipo de Layout</label>
                <select id="layout-type" onchange="changeLayout(this.value)">
                    <option value="hierarchical">Hierárquico</option>
                    <option value="radial">Radial</option>
                    <option value="force">Força Dirigida</option>
                    <option value="circular">Circular</option>
                </select>
            </div>
            <div class="config-option">
                <label>Espaçamento</label>
                <input type="range" id="spacing" min="50" max="300" value="150" 
                       oninput="updateSpacing(this.value)">
                <div class="range-value" id="spacing-value">150</div>
            </div>
        </div>
        
        <!-- Aparência -->
        <div class="config-section">
            <h4><i class="fas fa-palette"></i> Aparência</h4>
            <div class="config-option">
                <label>Tamanho dos Nós</label>
                <input type="range" id="node-size" min="10" max="50" value="25"
                       oninput="updateNodeSize(this.value)">
                <div class="range-value" id="node-size-value">25</div>
            </div>
            <div class="config-option">
                <label>Espessura das Conexões</label>
                <input type="range" id="edge-width" min="1" max="10" value="2"
                       oninput="updateEdgeWidth(this.value)">
                <div class="range-value" id="edge-width-value">2</div>
            </div>
            <div class="config-option">
                <label>Mostrar Labels</label>
                <select id="show-labels" onchange="toggleLabels(this.value)">
                    <option value="true">Sim</option>
                    <option value="false">Não</option>
                    <option value="hover">Apenas no Hover</option>
                </select>
            </div>
        </div>
        
        <!-- Física -->
        <div class="config-section">
            <h4><i class="fas fa-atom"></i> Física</h4>
            <div class="config-option">
                <label>Ativar Física</label>
                <select id="physics-enabled" onchange="togglePhysics(this.value)">
                    <option value="true">Sim</option>
                    <option value="false">Não</option>
                </select>
            </div>
            <div class="config-option">
                <label>Força de Repulsão</label>
                <input type="range" id="repulsion" min="0" max="200" value="50"
                       oninput="updateRepulsion(this.value)">
                <div class="range-value" id="repulsion-value">50</div>
            </div>
        </div>
        
        <!-- Correlações Ativas -->
        <div class="config-section">
            <h4><i class="fas fa-link"></i> Correlações Ativas</h4>
            <div class="correlation-list" id="correlation-list">
                <!-- Correlações serão listadas aqui -->
            </div>
        </div>
    </div>
    
    <!-- Modal de Configuração Qdrant -->
    <div class="modal" id="qdrant-config-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-database"></i> Configuração do Qdrant</h3>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>URL do Qdrant</label>
                    <input type="text" id="qdrant-url" placeholder="http://localhost:6333" 
                           value="http://qdr.vcia.com.br:6333">
                    <small style="color: #94A3B8; font-size: 0.75rem;">
                        Use http://localhost:6333 se Qdrant estiver rodando localmente
                    </small>
                </div>
                <div class="form-group">
                    <label>Nome da Coleção</label>
                    <input type="text" id="qdrant-collection" placeholder="knowledge_base" 
                           value="knowledge_consolidator">
                    <small style="color: #94A3B8; font-size: 0.75rem;">
                        Deixe vazio para detectar automaticamente
                    </small>
                </div>
                <div class="form-group">
                    <label>Opções de Conexão</label>
                    <div style="margin-top: 10px;">
                        <button class="btn" onclick="testQdrantConnection()" style="margin-right: 10px;">
                            <i class="fas fa-plug"></i> Testar Conexão
                        </button>
                        <button class="btn" onclick="loadDataFromFile()" style="margin-right: 10px;">
                            <i class="fas fa-file-import"></i> Carregar Arquivo JSON
                        </button>
                        <button class="btn" onclick="loadSampleData()">
                            <i class="fas fa-download"></i> Dados de Exemplo
                        </button>
                    </div>
                </div>
                <div id="connection-status" style="margin-top: 15px; padding: 10px; border-radius: 6px; display: none;">
                    <!-- Status da conexão aparecerá aqui -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeQdrantConfigModal()">Cancelar</button>
                <button class="btn btn-primary" onclick="connectWithConfig()">Conectar</button>
            </div>
        </div>
    </div>

    <!-- Modal de Nova Correlação -->
    <div class="modal" id="correlation-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-link"></i> Criar Nova Correlação</h3>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Elemento de Origem</label>
                    <select id="correlation-from">
                        <option value="">Selecione...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Elemento de Destino</label>
                    <select id="correlation-to">
                        <option value="">Selecione...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Tipo de Correlação</label>
                    <select id="correlation-type">
                        <option value="contains">Contém</option>
                        <option value="references">Referencia</option>
                        <option value="depends">Depende de</option>
                        <option value="similar">Similar a</option>
                        <option value="contrasts">Contrasta com</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Força da Correlação</label>
                    <input type="range" id="correlation-strength" min="1" max="10" value="5">
                    <div class="range-value" id="correlation-strength-value">5</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeCorrelationModal()">Cancelar</button>
                <button class="btn btn-primary" onclick="addCorrelation()">Adicionar</button>
            </div>
        </div>
    </div>
    
    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>
    
    <script src="js/GraphDataManager.js"></script>
    <script>
        // Variáveis Globais
        let network = null;
        let nodes = new vis.DataSet();
        let edges = new vis.DataSet();
        let selectedItems = new Set();
        let priorityOrder = [];
        let graphManager = new GraphDataManager();
        let qdrantConnector = null;
        
        /**
         * QdrantConnector Atualizado - Baseado nos dados reais do Qdrant
         * Collection: knowledge_consolidator
         * Vectores: 768 dimensões (nomic-embed-text embeddings)
         * Campos reais extraídos dos payloads existentes
         */
        class QdrantConnector {
            constructor(baseUrl = 'http://qdr.vcia.com.br:6333') {
                this.baseUrl = baseUrl;
                this.collectionName = 'knowledge_consolidator'; // Nome correto da collection
                this.cache = new Map();
                this.connected = false;
                this.lastSync = null;
                
                // Campos reais dos payloads mapeados
                this.realFieldMapping = {
                    // Campos de identificação
                    id: 'id',
                    documentId: 'documentId',
                    chunkId: 'chunkId',
                    originalChunkId: 'originalChunkId',
                    
                    // Campos de arquivo
                    fileName: 'fileName', 
                    filePath: 'filePath',
                    size: 'size',
                    
                    // Campos de chunk
                    chunkIndex: 'chunkIndex',
                    chunkText: 'chunkText',
                    content: 'content',
                    
                    // Campos de análise
                    categories: 'categories', // Array com múltiplas categorias
                    relevanceScore: 'relevanceScore',
                    intelligenceScore: 'intelligenceScore',
                    convergenceScore: 'convergenceScore',
                    impactScore: 'impactScore',
                    
                    // Campos de análise semântica
                    analysisType: 'analysisType',
                    intelligenceType: 'intelligenceType',
                    
                    // Campos de metadados
                    metadata: 'metadata',
                    enrichmentMetadata: 'enrichmentMetadata',
                    enrichmentLevel: 'enrichmentLevel',
                    
                    // Campos de cadeia de convergência
                    convergenceChains: 'convergenceChains',
                    
                    // Campos de versionamento
                    version: 'version',
                    mergeCount: 'mergeCount',
                    
                    // Timestamps
                    insertedAt: 'insertedAt',
                    lastModified: 'lastModified',
                    lastMerged: 'lastMerged'
                };
            }
            
            /**
             * Testa conexão e verifica se a collection knowledge_consolidator existe
             */
            async testConnection() {
                try {
                    // Verificar se servidor está rodando
                    const response = await fetch(`${this.baseUrl}/collections`);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    const collections = data.result?.collections || [];
                    
                    // Verificar se knowledge_consolidator existe
                    const targetCollection = collections.find(c => c.name === 'knowledge_consolidator');
                    if (!targetCollection) {
                        console.warn('Collection knowledge_consolidator não encontrada. Collections disponíveis:', 
                            collections.map(c => c.name).join(', '));
                        return false;
                    }
                    
                    // Verificar detalhes da collection
                    const collectionResponse = await fetch(`${this.baseUrl}/collections/${this.collectionName}`);
                    if (!collectionResponse.ok) throw new Error(`HTTP ${collectionResponse.status}`);
                    
                    const collectionData = await collectionResponse.json();
                    const pointsCount = collectionData.result?.points_count || 0;
                    const vectorSize = collectionData.result?.config?.params?.vectors?.size || 0;
                    
                    console.log(`✅ Qdrant conectado - Collection: ${this.collectionName}`);
                    console.log(`📊 Points: ${pointsCount}, Vector Dimensions: ${vectorSize}`);
                    
                    this.connected = true;
                    return true;
                    
                } catch (error) {
                    this.connected = false;
                    console.warn('⚠️ Erro ao conectar com Qdrant:', error.message);
                    return false;
                }
            }
            
            /**
             * Busca categorias reais usando o campo categories dos payloads
             */
            async getCategories() {
                const cacheKey = 'categories';
                if (this.cache.has(cacheKey) && this.isCacheValid(cacheKey)) {
                    return this.cache.get(cacheKey).data;
                }
                
                try {
                    // Buscar todos os pontos para extrair categorias únicas
                    const response = await fetch(`${this.baseUrl}/collections/${this.collectionName}/points/scroll`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            limit: 100, // Buscar em lotes
                            with_payload: true,
                            with_vector: false
                        })
                    });
                    
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    const points = data.result?.points || [];
                    
                    // Extrair categorias únicas de todos os pontos
                    const categorySet = new Set();
                    const categoryStats = new Map();
                    
                    points.forEach(point => {
                        const categories = point.payload?.categories;
                        if (Array.isArray(categories)) {
                            categories.forEach(cat => {
                                if (typeof cat === 'string' && cat.trim()) {
                                    categorySet.add(cat.trim());
                                    categoryStats.set(cat.trim(), (categoryStats.get(cat.trim()) || 0) + 1);
                                }
                            });
                        }
                    });
                    
                    // Converter para formato de nós
                    const categories = Array.from(categorySet).map(catName => ({
                        id: `cat_${catName.toLowerCase().replace(/\s+/g, '_')}`,
                        name: catName,
                        color: this.getCategoryColor(catName),
                        count: categoryStats.get(catName) || 0,
                        description: `Categoria com ${categoryStats.get(catName) || 0} ocorrências`,
                        type: 'category'
                    }));
                    
                    this.cache.set(cacheKey, {
                        data: categories,
                        timestamp: Date.now()
                    });
                    
                    console.log(`📂 Categorias encontradas: ${categories.length}`);
                    return categories;
                } catch (error) {
                    console.warn('Erro ao buscar categorias:', error);
                    return this.getFallbackCategories();
                }
            }
            
            /**
             * Busca arquivos reais agrupados por fileName
             */
            async getFiles() {
                const cacheKey = 'files';
                if (this.cache.has(cacheKey) && this.isCacheValid(cacheKey)) {
                    return this.cache.get(cacheKey).data;
                }
                
                try {
                    // Buscar pontos com scroll para pegar todos os dados
                    let allPoints = [];
                    let nextOffset = null;
                    
                    do {
                        const response = await fetch(`${this.baseUrl}/collections/${this.collectionName}/points/scroll`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                limit: 100,
                                with_payload: true,
                                with_vector: false,
                                ...(nextOffset && { offset: nextOffset })
                            })
                        });
                        
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        
                        const data = await response.json();
                        const points = data.result?.points || [];
                        allPoints = allPoints.concat(points);
                        nextOffset = data.result?.next_page_offset;
                        
                    } while (nextOffset && allPoints.length < 200); // Limitar para evitar sobrecarga
                    
                    // Agrupar por fileName
                    const filesMap = new Map();
                    
                    allPoints.forEach(point => {
                        const payload = point.payload;
                        const fileName = payload?.fileName;
                        
                        if (!fileName) return;
                        
                        if (!filesMap.has(fileName)) {
                            filesMap.set(fileName, {
                                id: `file_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`,
                                name: fileName,
                                path: payload?.filePath || '',
                                size: this.formatFileSize(payload?.size || 0),
                                relevance: Math.round((payload?.relevanceScore || payload?.intelligenceScore || 50)),
                                categories: Array.from(new Set(payload?.categories || [])),
                                analyzed: payload?.analyzed !== false,
                                lastModified: payload?.lastModified || payload?.insertedAt,
                                chunks: 1,
                                type: 'file',
                                analysisType: payload?.analysisType || payload?.intelligenceType
                            });
                        } else {
                            // Agregar dados de múltiplos chunks
                            const existing = filesMap.get(fileName);
                            existing.chunks = (existing.chunks || 0) + 1;
                            
                            // Mesclar categorias únicas
                            if (payload?.categories) {
                                const allCats = [...existing.categories, ...payload.categories];
                                existing.categories = Array.from(new Set(allCats));
                            }
                            
                            // Atualizar relevância (média ou máxima)
                            const newRelevance = payload?.relevanceScore || payload?.intelligenceScore || 50;
                            existing.relevance = Math.max(existing.relevance, newRelevance);
                        }
                    });
                    
                    const files = Array.from(filesMap.values());
                    
                    this.cache.set(cacheKey, {
                        data: files,
                        timestamp: Date.now()
                    });
                    
                    console.log(`📄 Arquivos encontrados: ${files.length}`);
                    return files;
                    
                } catch (error) {
                    console.warn('Erro ao buscar arquivos:', error);
                    return this.getFallbackFiles();
                }
            }
            
            /**
             * Busca entidades baseadas em convergenceChains
             */
            async getEntities() {
                const cacheKey = 'entities';
                if (this.cache.has(cacheKey) && this.isCacheValid(cacheKey)) {
                    return this.cache.get(cacheKey).data;
                }
                
                try {
                    // Buscar pontos que têm convergenceChains
                    const response = await fetch(`${this.baseUrl}/collections/${this.collectionName}/points/scroll`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            limit: 50,
                            with_payload: true,
                            with_vector: false,
                            filter: {
                                must: [
                                    {
                                        key: "convergenceChains",
                                        match: { any: [] } // Points que têm o campo convergenceChains
                                    }
                                ]
                            }
                        })
                    });
                    
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    const points = data.result?.points || [];
                    
                    // Extrair entidades únicas dos convergenceChains
                    const entitiesMap = new Map();
                    
                    points.forEach(point => {
                        const chains = point.payload?.convergenceChains;
                        if (Array.isArray(chains)) {
                            chains.forEach(chain => {
                                const theme = chain.theme || 'Tema Sem Nome';
                                const participants = chain.participants || [];
                                const strength = chain.strength || 0;
                                
                                const entityId = `entity_${theme.toLowerCase().replace(/[^a-zA-Z0-9]/g, '_')}`;
                                
                                if (!entitiesMap.has(entityId)) {
                                    entitiesMap.set(entityId, {
                                        id: entityId,
                                        name: theme,
                                        type: 'Convergence Theme',
                                        status: strength > 0.7 ? 'Alto' : 'Médio',
                                        relevance: Math.round(strength * 100),
                                        participants: participants.length,
                                        chainId: chain.chainId
                                    });
                                }
                            });
                        }
                    });
                    
                    const entities = Array.from(entitiesMap.values());
                    
                    this.cache.set(cacheKey, {
                        data: entities,
                        timestamp: Date.now()
                    });
                    
                    console.log(`🔗 Entidades encontradas: ${entities.length}`);
                    return entities;
                    
                } catch (error) {
                    console.warn('Erro ao buscar entidades:', error);
                    return this.getFallbackEntities();
                }
            }
            
            /**
             * Busca cadeias de convergência reais dos dados
             */
            async getConvergenceChains(limit = 20) {
                try {
                    const response = await fetch(`${this.baseUrl}/collections/${this.collectionName}/points/scroll`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            limit: limit,
                            with_payload: true,
                            with_vector: false,
                            filter: {
                                must: [
                                    {
                                        key: "convergenceScore",
                                        range: { gte: 15 } // Points com convergenceScore >= 15
                                    }
                                ]
                            }
                        })
                    });
                    
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    const points = data.result?.points || [];
                    
                    return points.map(point => {
                        const payload = point.payload;
                        return {
                            id: point.id,
                            name: payload?.analysisType || payload?.intelligenceType || 'Padrão Detectado',
                            strength: (payload?.convergenceScore || payload?.intelligenceScore || 50) / 100,
                            entities: payload?.convergenceChains?.map(c => c.participants || []).flat() || [],
                            files: [payload?.fileName].filter(Boolean),
                            type: payload?.intelligenceType || 'semantic',
                            score: payload?.convergenceScore || payload?.intelligenceScore || 50
                        };
                    });
                    
                } catch (error) {
                    console.warn('Erro ao buscar cadeias de convergência:', error);
                    return [];
                }
            }
            
            /**
             * Busca dados completos com base nos dados reais do Qdrant
             */
            async getAllData() {
                console.log('🔍 Carregando dados reais do Qdrant knowledge_consolidator...');
                updateQdrantStatus('connecting', 'Conectando...');
                showToast('Conectando com Qdrant...', 'info');
                
                const isConnected = await this.testConnection();
                if (!isConnected) {
                    updateQdrantStatus('error', 'Collection não encontrada');
                    showToast('Collection knowledge_consolidator não encontrada', 'error');
                    return this.getFallbackData();
                }
                
                try {
                    // Carregar dados em paralelo
                    const [categories, files, entities, convergenceChains] = await Promise.all([
                        this.getCategories(),
                        this.getFiles(),
                        this.getEntities(),
                        this.getConvergenceChains()
                    ]);
                    
                    this.lastSync = new Date().toISOString();
                    
                    const data = {
                        categories,
                        files,
                        entities,
                        convergenceChains,
                        metadata: {
                            totalNodes: categories.length + files.length + entities.length,
                            totalConnections: convergenceChains.length,
                            lastSync: this.lastSync,
                            source: 'Qdrant Real Data',
                            collection: this.collectionName,
                            fieldsMapping: this.realFieldMapping
                        }
                    };
                    
                    updateQdrantStatus('connected', `${data.metadata.totalNodes} nós carregados`);
                    showToast(`Dados carregados: ${data.metadata.totalNodes} nós, ${data.metadata.totalConnections} conexões`, 'success');
                    
                    console.log('📊 Dados carregados do Qdrant:', {
                        categories: categories.length,
                        files: files.length,
                        entities: entities.length,
                        convergenceChains: convergenceChains.length
                    });
                    
                    return data;
                    
                } catch (error) {
                    console.error('Erro ao carregar dados do Qdrant:', error);
                    updateQdrantStatus('error', 'Erro no carregamento');
                    showToast('Erro ao carregar dados. Usando fallback.', 'error');
                    return this.getFallbackData();
                }
            }
            
            /**
             * Verifica se o cache é válido (5 minutos)
             */
            isCacheValid(key) {
                const cached = this.cache.get(key);
                if (!cached) return false;
                const fiveMinutes = 5 * 60 * 1000;
                return (Date.now() - cached.timestamp) < fiveMinutes;
            }
            
            /**
             * Formatar tamanho de arquivo
             */
            formatFileSize(bytes) {
                if (!bytes || bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
            }
            
            /**
             * Obter cor específica para categoria
             */
            getCategoryColor(categoryName) {
                const colors = {
                    'técnico': '#3B82F6',
                    'estratégico': '#10B981', 
                    'insight': '#F59E0B',
                    'aprendizado': '#8B5CF6',
                    'ideia': '#EF4444',
                    'momento decisivo': '#F97316'
                };
                
                const key = categoryName.toLowerCase();
                return colors[key] || this.getRandomColor();
            }
            
            /**
             * Gerar cor aleatória para categorias
             */
            getRandomColor() {
                const colors = ['#10B981', '#3B82F6', '#F59E0B', '#8B5CF6', '#EF4444', '#06B6D4', '#84CC16'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            /**
             * Dados de fallback caso Qdrant não esteja disponível
             */
            getFallbackData() {
                return {
                    categories: this.getFallbackCategories(),
                    files: this.getFallbackFiles(),
                    entities: this.getFallbackEntities(),
                    convergenceChains: [],
                    metadata: {
                        totalNodes: 15,
                        totalConnections: 0,
                        lastSync: new Date().toISOString(),
                        source: 'Fallback'
                    }
                };
            }
            
            getFallbackCategories() {
                return [
                    { id: 'cat_tecnico', name: 'Técnico', color: '#3B82F6', count: 0, type: 'category' },
                    { id: 'cat_estrategico', name: 'Estratégico', color: '#10B981', count: 0, type: 'category' },
                    { id: 'cat_insight', name: 'Insight', color: '#F59E0B', count: 0, type: 'category' },
                    { id: 'cat_aprendizado', name: 'Aprendizado', color: '#8B5CF6', count: 0, type: 'category' }
                ];
            }
            
            getFallbackFiles() {
                return [
                    { 
                        id: 'file_fallback', 
                        name: 'Dados não disponíveis', 
                        type: 'file', 
                        relevance: 0,
                        categories: [],
                        chunks: 0
                    }
                ];
            }
            
            getFallbackEntities() {
                return [
                    { 
                        id: 'entity_fallback', 
                        name: 'Entidades não disponíveis', 
                        type: 'Entity',
                        status: 'N/A',
                        relevance: 0
                    }
                ];
            }
        }
        
        // Dados de exemplo (serão substituídos pelos dados reais do sistema)
        const mockData = {
            categories: [
                { id: 'cat1', name: 'Vendas', count: 45, color: '#10B981' },
                { id: 'cat2', name: 'Marketing', count: 32, color: '#3B82F6' },
                { id: 'cat3', name: 'Suporte', count: 28, color: '#F59E0B' },
                { id: 'cat4', name: 'Desenvolvimento', count: 67, color: '#8B5CF6' },
                { id: 'cat5', name: 'Estratégia', count: 15, color: '#EF4444' }
            ],
            files: [
                { id: 'file1', name: 'proposta_cliente_a.pdf', size: '2.4 MB', relevance: 85 },
                { id: 'file2', name: 'relatorio_vendas_q1.xlsx', size: '1.2 MB', relevance: 92 },
                { id: 'file3', name: 'estrategia_2025.docx', size: '845 KB', relevance: 78 },
                { id: 'file4', name: 'meeting_notes.md', size: '23 KB', relevance: 65 },
                { id: 'file5', name: 'api_documentation.json', size: '156 KB', relevance: 70 }
            ],
            entities: [
                { id: 'ent1', name: 'DedetClean', type: 'Cliente', status: 'Ativo' },
                { id: 'ent2', name: 'Hospital Central', type: 'Prospect', status: 'Negociação' },
                { id: 'ent3', name: 'Tech Solutions', type: 'Parceiro', status: 'Ativo' },
                { id: 'ent4', name: 'Prefeitura SP', type: 'Cliente', status: 'Ativo' },
                { id: 'ent5', name: 'StartUp Alpha', type: 'Lead', status: 'Qualificado' }
            ]
        };
        
        // Inicialização
        window.addEventListener('load', async () => {
            // Inicializar QdrantConnector
            qdrantConnector = new QdrantConnector();
            
            initializeNetwork();
            
            // Carregar dados reais do Qdrant automaticamente
            await loadRealData();
            
            // IMPORTANTE: Inicializar com nó central para mostrar que funciona
            initializeDefaultNodes();
            
            // Configurar drag & drop DEPOIS da rede estar completamente inicializada
            setTimeout(() => {
                setupDragAndDrop();
                console.log('Drag and Drop configurado após inicialização da rede');
            }, 1000);
        });
        
        // Função para inicializar nós padrão
        function initializeDefaultNodes() {
            // Adicionar nó central
            nodes.add({
                id: 'center',
                label: 'Knowledge Base',
                color: '#6366F1',
                size: 40,
                shape: 'hexagon',
                font: { size: 16, bold: true, color: '#FFFFFF' },
                x: 0,
                y: 0,
                title: 'Centro do Conhecimento\n(Arraste items aqui)'
            });
            
            // Adicionar alguns exemplos para demonstração
            nodes.add([
                {
                    id: 'example-cat',
                    label: 'Exemplo: Categoria',
                    color: '#10B981',
                    shape: 'square',
                    size: 25,
                    x: -200,
                    y: -100,
                    title: 'Categoria de exemplo\n(Clique duplo para editar)'
                },
                {
                    id: 'example-file',
                    label: 'Exemplo: Arquivo',
                    color: '#F59E0B',
                    shape: 'dot',
                    size: 20,
                    x: 200,
                    y: -100,
                    title: 'Arquivo de exemplo\n(Arraste novos items da esquerda)'
                },
                {
                    id: 'example-entity',
                    label: 'Exemplo: Entidade',
                    color: '#8B5CF6',
                    shape: 'diamond',
                    size: 25,
                    x: 0,
                    y: 150,
                    title: 'Entidade de exemplo\n(Use "Nova Correlação" para conectar)'
                }
            ]);
            
            // Adicionar conexões de exemplo
            edges.add([
                { 
                    from: 'center', 
                    to: 'example-cat',
                    color: { color: '#10B981', opacity: 0.6 },
                    title: 'Conexão de exemplo'
                },
                { 
                    from: 'center', 
                    to: 'example-file',
                    color: { color: '#F59E0B', opacity: 0.6 },
                    title: 'Conexão de exemplo'
                },
                { 
                    from: 'center', 
                    to: 'example-entity',
                    color: { color: '#8B5CF6', opacity: 0.6 },
                    title: 'Conexão de exemplo'
                }
            ]);
            
            showToast('Grafo inicializado! Arraste items da esquerda ou use "Gerar Grafo"', 'success');
        }
        
        // Inicializar Rede vis.js
        function initializeNetwork() {
            const container = document.getElementById('mynetwork');
            const data = { nodes: nodes, edges: edges };
            
            const options = {
                nodes: {
                    borderWidth: 2,
                    shadow: true,
                    font: {
                        size: 14,
                        color: '#F1F5F9'
                    }
                },
                edges: {
                    width: 2,
                    smooth: {
                        type: 'continuous'
                    },
                    color: {
                        inherit: 'from'
                    },
                    arrows: {
                        to: {
                            enabled: true,
                            scaleFactor: 0.5
                        }
                    }
                },
                physics: {
                    enabled: true,
                    forceAtlas2Based: {
                        gravitationalConstant: -50,
                        centralGravity: 0.01,
                        springLength: 150,
                        springConstant: 0.08
                    }
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 300,
                    zoomView: true,
                    dragView: true
                }
            };
            
            network = new vis.Network(container, data, options);
            
            // Eventos
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    showNodeDetails(params.nodes[0]);
                }
            });
            
            network.on("doubleClick", function(params) {
                if (params.nodes.length > 0) {
                    editNode(params.nodes[0]);
                }
            });
        }
        
        // Carregar Listas de Dados
        function loadDataLists() {
            // Categorias
            const categoriesList = document.getElementById('categories-list');
            mockData.categories.forEach(cat => {
                categoriesList.innerHTML += createSelectableItem('category', cat);
            });
            
            // Arquivos
            const filesList = document.getElementById('files-list');
            mockData.files.forEach(file => {
                filesList.innerHTML += createSelectableItem('file', file);
            });
            
            // Entidades
            const entitiesList = document.getElementById('entities-list');
            mockData.entities.forEach(entity => {
                entitiesList.innerHTML += createSelectableItem('entity', entity);
            });
        }
        
        // Criar Item Selecionável
        function createSelectableItem(type, item) {
            const itemId = `${type}-${item.id}`;
            let badge = '';
            let meta = '';
            
            switch(type) {
                case 'category':
                    badge = `<span class="item-badge">${item.count} itens</span>`;
                    meta = `<div class="item-meta">Cor: ${item.color}</div>`;
                    break;
                case 'file':
                    badge = `<span class="item-badge">${item.relevance}%</span>`;
                    meta = `<div class="item-meta">${item.size}</div>`;
                    break;
                case 'entity':
                    badge = `<span class="item-badge">${item.status}</span>`;
                    meta = `<div class="item-meta">Tipo: ${item.type}</div>`;
                    break;
            }
            
            return `
                <div class="selectable-item" id="${itemId}" draggable="true" 
                     data-type="${type}" data-id="${item.id}" data-name="${item.name}">
                    <input type="checkbox" class="item-checkbox" 
                           onchange="toggleItemSelection('${itemId}')">
                    <div class="item-info">
                        <div class="item-name">${item.name}</div>
                        ${meta}
                    </div>
                    ${badge}
                </div>
            `;
        }
        
        // Toggle Seleção de Item
        function toggleItemSelection(itemId) {
            const item = document.getElementById(itemId);
            const checkbox = item.querySelector('.item-checkbox');
            
            if (checkbox.checked) {
                item.classList.add('selected');
                selectedItems.add(itemId);
            } else {
                item.classList.remove('selected');
                selectedItems.delete(itemId);
            }
            
            updateCorrelationOptions();
        }
        
        // Configurar Drag and Drop
        function setupDragAndDrop() {
            // Configurar items arrastáveis
            document.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('selectable-item')) {
                    e.target.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('itemId', e.target.id);
                    e.dataTransfer.setData('itemType', e.target.dataset.type);
                    e.dataTransfer.setData('itemName', e.target.dataset.name);
                }
            });
            
            document.addEventListener('dragend', (e) => {
                if (e.target.classList.contains('selectable-item')) {
                    e.target.classList.remove('dragging');
                }
            });
            
            // NOVO: Configurar área do grafo como zona de drop
            const graphContainer = document.getElementById('mynetwork');
            
            graphContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                graphContainer.style.border = '2px dashed #3B82F6';
                graphContainer.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
            });
            
            graphContainer.addEventListener('dragleave', (e) => {
                graphContainer.style.border = 'none';
                graphContainer.style.backgroundColor = 'transparent';
            });
            
            graphContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                graphContainer.style.border = 'none';
                graphContainer.style.backgroundColor = 'transparent';
                
                const itemId = e.dataTransfer.getData('itemId');
                const itemType = e.dataTransfer.getData('itemType');
                const itemName = e.dataTransfer.getData('itemName');
                
                // Calcular posição no grafo baseado na posição do mouse
                const rect = graphContainer.getBoundingClientRect();
                const x = e.clientX - rect.left - rect.width / 2;
                const y = e.clientY - rect.top - rect.height / 2;
                
                // Adicionar nó diretamente ao grafo
                addNodeToGraph(itemId, itemName, itemType, x, y);
            });
            
            // Configurar zona de prioridade (mantém funcionalidade original)
            const dropZone = document.getElementById('priority-zone');
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('active');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('active');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('active');
                
                const itemId = e.dataTransfer.getData('itemId');
                const item = document.getElementById(itemId);
                
                if (item && !priorityOrder.includes(itemId)) {
                    priorityOrder.push(itemId);
                    updatePriorityList();
                    showToast('Item adicionado à ordem de prioridade', 'success');
                }
            });
        }
        
        // NOVA FUNÇÃO: Adicionar nó diretamente ao grafo
        function addNodeToGraph(itemId, itemName, itemType, x, y) {
            // Verificar se o nó já existe
            if (nodes.get(itemId)) {
                showToast('Este item já está no grafo', 'error');
                return;
            }
            
            // Definir propriedades visuais baseadas no tipo
            let nodeColor = '#3B82F6';
            let nodeShape = 'dot';
            let nodeSize = 25;
            
            switch(itemType) {
                case 'category':
                    nodeColor = '#10B981';
                    nodeShape = 'square';
                    nodeSize = 30;
                    break;
                case 'file':
                    nodeColor = '#F59E0B';
                    nodeShape = 'dot';
                    nodeSize = 20;
                    break;
                case 'entity':
                    nodeColor = '#8B5CF6';
                    nodeShape = 'diamond';
                    nodeSize = 25;
                    break;
            }
            
            // Adicionar o nó
            nodes.add({
                id: itemId,
                label: itemName,
                x: x,
                y: y,
                color: nodeColor,
                shape: nodeShape,
                size: nodeSize,
                title: `${itemType}: ${itemName}\n(Clique duplo para editar)`,
                physics: false // Inicialmente sem física para ficar onde foi dropado
            });
            
            // Se houver outros nós, criar conexão automática com o mais próximo
            const allNodes = nodes.get();
            if (allNodes.length > 1) {
                let closestNode = null;
                let minDistance = Infinity;
                
                allNodes.forEach(node => {
                    if (node.id !== itemId) {
                        const distance = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestNode = node;
                        }
                    }
                });
                
                if (closestNode && minDistance < 200) { // Conectar apenas se estiver próximo
                    edges.add({
                        id: `edge-auto-${itemId}-${closestNode.id}`,
                        from: itemId,
                        to: closestNode.id,
                        width: 1,
                        color: { color: '#64748b', opacity: 0.5 },
                        dashes: true,
                        title: 'Conexão automática (clique direito para remover)'
                    });
                }
            }
            
            showToast(`${itemName} adicionado ao grafo!`, 'success');
            
            // Habilitar física após um breve delay
            setTimeout(() => {
                nodes.update({ id: itemId, physics: true });
            }, 1000);
        }
        
        // Atualizar Lista de Prioridade
        function updatePriorityList() {
            const priorityList = document.getElementById('priority-list');
            priorityList.innerHTML = '';
            
            priorityOrder.forEach((itemId, index) => {
                const item = document.getElementById(itemId);
                if (item) {
                    const name = item.dataset.name;
                    const type = item.dataset.type;
                    
                    priorityList.innerHTML += `
                        <div class="correlation-item">
                            <span style="color: #3B82F6; font-weight: bold;">${index + 1}</span>
                            <div class="correlation-info">
                                <div class="correlation-from">${name}</div>
                                <div class="correlation-strength">Tipo: ${type}</div>
                            </div>
                            <i class="fas fa-times remove-correlation" 
                               onclick="removeFromPriority('${itemId}')"></i>
                        </div>
                    `;
                }
            });
        }
        
        // Remover da Prioridade
        function removeFromPriority(itemId) {
            priorityOrder = priorityOrder.filter(id => id !== itemId);
            updatePriorityList();
            showToast('Item removido da ordem de prioridade');
        }
        
        // Gerar Grafo (com items selecionados)
        function generateGraph() {
            // Não limpar o grafo se já houver nós (permite adicionar incrementalmente)
            const hasNodes = nodes.length > 0;
            
            if (!hasNodes) {
                showLoading(true);
            }
            
            setTimeout(() => {
                // Criar nó central apenas se não existir
                if (!nodes.get('center') && !hasNodes) {
                    nodes.add({
                        id: 'center',
                        label: 'Knowledge Base',
                        color: '#6366F1',
                        size: 40,
                        shape: 'hexagon',
                        font: { size: 16, bold: true },
                        x: 0,
                        y: 0,
                        fixed: { x: true, y: true }
                    });
                }
                
                // Adicionar items selecionados
                const itemsToAdd = Array.from(selectedItems);
                
                if (itemsToAdd.length === 0) {
                    showToast('Selecione items ou arraste-os para o grafo', 'error');
                    showLoading(false);
                    return;
                }
                
                itemsToAdd.forEach((itemId, index) => {
                    const item = document.getElementById(itemId);
                    if (item && !nodes.get(itemId)) { // Só adicionar se não existir
                        const type = item.dataset.type;
                        const name = item.dataset.name;
                        
                        let nodeColor = '#3B82F6';
                        let nodeShape = 'dot';
                        let nodeSize = 20;
                        
                        switch(type) {
                            case 'category':
                                nodeColor = '#10B981';
                                nodeShape = 'square';
                                nodeSize = 25;
                                break;
                            case 'file':
                                nodeColor = '#F59E0B';
                                nodeShape = 'dot';
                                nodeSize = 15;
                                break;
                            case 'entity':
                                nodeColor = '#8B5CF6';
                                nodeShape = 'diamond';
                                nodeSize = 20;
                                break;
                        }
                        
                        // Posicionar em círculo ao redor do centro
                        const angle = (2 * Math.PI * index) / itemsToAdd.length;
                        const radius = 150;
                        
                        // Adicionar nó
                        nodes.add({
                            id: itemId,
                            label: name,
                            color: nodeColor,
                            shape: nodeShape,
                            size: nodeSize,
                            x: radius * Math.cos(angle),
                            y: radius * Math.sin(angle),
                            title: `${type}: ${name}`
                        });
                        
                        // Conectar ao centro se existir
                        if (nodes.get('center')) {
                            edges.add({
                                from: 'center',
                                to: itemId,
                                width: 2
                            });
                        }
                    }
                });
                
                if (!hasNodes) {
                    showLoading(false);
                }
                
                showToast('Items adicionados ao grafo!', 'success');
                
                // Desmarcar checkboxes após adicionar
                document.querySelectorAll('.item-checkbox:checked').forEach(cb => {
                    cb.checked = false;
                    const item = cb.closest('.selectable-item');
                    if (item) item.classList.remove('selected');
                });
                selectedItems.clear();
                
                // Salvar no GraphDataManager
                saveCurrentGraph();
            }, hasNodes ? 0 : 500);
        }
        
        // Salvar Grafo Atual
        function saveCurrentGraph() {
            graphManager.nodes.clear();
            graphManager.edges.clear();
            
            nodes.forEach(node => {
                graphManager.addNode(node);
            });
            
            edges.forEach(edge => {
                graphManager.addEdge(edge);
            });
            
            graphManager.saveToLocalStorage('graphEditorData');
        }
        
        // Limpar Grafo
        function clearGraph() {
            nodes.clear();
            edges.clear();
            selectedItems.clear();
            priorityOrder = [];
            
            document.querySelectorAll('.item-checkbox').forEach(cb => {
                cb.checked = false;
            });
            
            document.querySelectorAll('.selectable-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            updatePriorityList();
            showToast('Grafo limpo');
        }
        
        // Auto Layout
        function autoLayout() {
            const layoutType = document.getElementById('layout-type').value;
            
            let options = {};
            
            switch(layoutType) {
                case 'hierarchical':
                    options = {
                        layout: {
                            hierarchical: {
                                direction: 'UD',
                                sortMethod: 'directed',
                                shakeTowards: 'roots'
                            }
                        }
                    };
                    break;
                case 'radial':
                    // Implementar layout radial customizado
                    applyRadialLayout();
                    return;
                case 'circular':
                    // Implementar layout circular customizado
                    applyCircularLayout();
                    return;
            }
            
            network.setOptions(options);
            showToast('Layout aplicado');
        }
        
        // Layout Radial
        function applyRadialLayout() {
            const nodeIds = nodes.getIds();
            const center = nodeIds.find(id => id === 'center') || nodeIds[0];
            const others = nodeIds.filter(id => id !== center);
            
            // Posicionar centro
            network.moveNode(center, 0, 0);
            
            // Posicionar outros em círculo
            const radius = 200;
            others.forEach((nodeId, index) => {
                const angle = (2 * Math.PI * index) / others.length;
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                network.moveNode(nodeId, x, y);
            });
        }
        
        // Layout Circular
        function applyCircularLayout() {
            const nodeIds = nodes.getIds();
            const radius = 250;
            
            nodeIds.forEach((nodeId, index) => {
                const angle = (2 * Math.PI * index) / nodeIds.length;
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                network.moveNode(nodeId, x, y);
            });
        }
        
        // Mostrar Modal de Correlação
        function showCorrelationModal() {
            const modal = document.getElementById('correlation-modal');
            modal.classList.add('show');
            
            // Atualizar opções
            updateCorrelationOptions();
            
            // Atualizar valor do slider
            document.getElementById('correlation-strength').oninput = function() {
                document.getElementById('correlation-strength-value').textContent = this.value;
            };
        }
        
        // Atualizar Opções de Correlação
        function updateCorrelationOptions() {
            const fromSelect = document.getElementById('correlation-from');
            const toSelect = document.getElementById('correlation-to');
            
            fromSelect.innerHTML = '<option value="">Selecione...</option>';
            toSelect.innerHTML = '<option value="">Selecione...</option>';
            
            nodes.forEach(node => {
                const option = `<option value="${node.id}">${node.label}</option>`;
                fromSelect.innerHTML += option;
                toSelect.innerHTML += option;
            });
        }
        
        // Fechar Modal
        function closeCorrelationModal() {
            document.getElementById('correlation-modal').classList.remove('show');
        }
        
        // Adicionar Correlação
        function addCorrelation() {
            const from = document.getElementById('correlation-from').value;
            const to = document.getElementById('correlation-to').value;
            const type = document.getElementById('correlation-type').value;
            const strength = document.getElementById('correlation-strength').value;
            
            if (from && to && from !== to) {
                const edgeId = `edge-${from}-${to}-${Date.now()}`;
                
                edges.add({
                    id: edgeId,
                    from: from,
                    to: to,
                    label: type,
                    width: parseInt(strength) / 2,
                    color: {
                        color: strength > 7 ? '#EF4444' : strength > 4 ? '#F59E0B' : '#3B82F6',
                        opacity: 0.8
                    },
                    arrows: {
                        to: {
                            enabled: true,
                            scaleFactor: 1
                        }
                    }
                });
                
                updateCorrelationList();
                closeCorrelationModal();
                showToast('Correlação adicionada', 'success');
                saveCurrentGraph();
            } else {
                showToast('Selecione elementos diferentes', 'error');
            }
        }
        
        // Atualizar Lista de Correlações
        function updateCorrelationList() {
            const list = document.getElementById('correlation-list');
            list.innerHTML = '';
            
            edges.forEach(edge => {
                const fromNode = nodes.get(edge.from);
                const toNode = nodes.get(edge.to);
                
                if (fromNode && toNode) {
                    list.innerHTML += `
                        <div class="correlation-item">
                            <i class="fas fa-link"></i>
                            <div class="correlation-info">
                                <div class="correlation-from">${fromNode.label}</div>
                                <div class="correlation-to">→ ${toNode.label}</div>
                                <div class="correlation-strength">${edge.label || 'Conexão'}</div>
                            </div>
                            <i class="fas fa-trash remove-correlation" 
                               onclick="removeCorrelation('${edge.id}')"></i>
                        </div>
                    `;
                }
            });
        }
        
        // Remover Correlação
        function removeCorrelation(edgeId) {
            edges.remove(edgeId);
            updateCorrelationList();
            showToast('Correlação removida');
            saveCurrentGraph();
        }
        
        // Exportar Grafo
        function exportGraph() {
            const format = prompt('Escolha o formato:\n1. JSON\n2. CSV\n3. GraphML\n4. GEXF\n5. Cytoscape\n6. D3');
            
            let exportData;
            let filename;
            let mimeType;
            
            switch(format) {
                case '1':
                    exportData = graphManager.exportToJSON();
                    filename = 'graph-export.json';
                    mimeType = 'application/json';
                    break;
                case '2':
                    const csv = graphManager.exportToCSV();
                    exportData = csv.nodes + '\n\n' + csv.edges;
                    filename = 'graph-export.csv';
                    mimeType = 'text/csv';
                    break;
                case '3':
                    exportData = graphManager.exportToGraphML();
                    filename = 'graph-export.graphml';
                    mimeType = 'application/xml';
                    break;
                case '4':
                    exportData = graphManager.exportToGEXF();
                    filename = 'graph-export.gexf';
                    mimeType = 'application/xml';
                    break;
                case '5':
                    exportData = JSON.stringify(graphManager.exportToCytoscape(), null, 2);
                    filename = 'graph-export-cytoscape.json';
                    mimeType = 'application/json';
                    break;
                case '6':
                    exportData = JSON.stringify(graphManager.exportToD3(), null, 2);
                    filename = 'graph-export-d3.json';
                    mimeType = 'application/json';
                    break;
                default:
                    showToast('Formato inválido', 'error');
                    return;
            }
            
            // Download do arquivo
            const blob = new Blob([exportData], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('Grafo exportado com sucesso!', 'success');
        }
        
        // Importar Dados
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            
                            // Limpar grafo atual
                            nodes.clear();
                            edges.clear();
                            
                            // Carregar novos dados
                            if (data.nodes) {
                                data.nodes.forEach(node => nodes.add(node));
                            }
                            if (data.edges) {
                                data.edges.forEach(edge => edges.add(edge));
                            }
                            
                            updateCorrelationList();
                            showToast('Dados importados com sucesso!', 'success');
                        } catch (error) {
                            showToast('Erro ao importar arquivo', 'error');
                            console.error(error);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            
            input.click();
        }
        
        // Carregar dados do Knowledge Consolidator
        function loadFromKnowledgeConsolidator() {
            if (window.KC && window.KC.CategoryManager && window.KC.AppState) {
                const categories = window.KC.CategoryManager.getAll();
                const files = window.KC.AppState.get('files') || [];
                
                // Carregar dados reais
                graphManager.loadFromCategoryManager(categories, files);
                
                // Atualizar listas
                updateDataListsFromKC(categories, files);
                
                showToast('Dados carregados do Knowledge Consolidator', 'success');
            }
        }
        
        // Atualizar Listas com dados do KC
        function updateDataListsFromKC(categories, files) {
            // Atualizar categorias
            const categoriesList = document.getElementById('categories-list');
            categoriesList.innerHTML = '';
            categories.forEach(cat => {
                categoriesList.innerHTML += createSelectableItem('category', {
                    id: cat.id,
                    name: cat.name,
                    count: cat.files ? cat.files.length : 0,
                    color: cat.color
                });
            });
            
            // Atualizar arquivos
            const filesList = document.getElementById('files-list');
            filesList.innerHTML = '';
            files.forEach((file, index) => {
                filesList.innerHTML += createSelectableItem('file', {
                    id: index,
                    name: file.name,
                    size: formatFileSize(file.size),
                    relevance: file.relevance || 50
                });
            });
        }
        
        // Formatar tamanho de arquivo
        function formatFileSize(bytes) {
            if (!bytes) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        // Toggle Seção
        function toggleSection(element) {
            element.classList.toggle('collapsed');
            const content = element.nextElementSibling;
            content.classList.toggle('collapsed');
        }
        
        // Configurações de Layout
        function changeLayout(value) {
            autoLayout();
        }
        
        function updateSpacing(value) {
            document.getElementById('spacing-value').textContent = value;
            network.setOptions({
                physics: {
                    forceAtlas2Based: {
                        springLength: parseInt(value)
                    }
                }
            });
        }
        
        function updateNodeSize(value) {
            document.getElementById('node-size-value').textContent = value;
            nodes.forEach(node => {
                nodes.update({ id: node.id, size: parseInt(value) });
            });
        }
        
        function updateEdgeWidth(value) {
            document.getElementById('edge-width-value').textContent = value;
            edges.forEach(edge => {
                edges.update({ id: edge.id, width: parseInt(value) });
            });
        }
        
        function toggleLabels(value) {
            let hideLabels = value === 'false';
            let hoverOnly = value === 'hover';
            
            nodes.forEach(node => {
                if (hideLabels) {
                    nodes.update({ id: node.id, label: '' });
                } else if (hoverOnly) {
                    nodes.update({ 
                        id: node.id, 
                        label: undefined,
                        title: node.label 
                    });
                } else {
                    nodes.update({ id: node.id, label: node.label || node.id });
                }
            });
        }
        
        function togglePhysics(value) {
            network.setOptions({
                physics: { enabled: value === 'true' }
            });
        }
        
        function updateRepulsion(value) {
            document.getElementById('repulsion-value').textContent = value;
            network.setOptions({
                physics: {
                    forceAtlas2Based: {
                        gravitationalConstant: -parseInt(value)
                    }
                }
            });
        }
        
        // Mostrar/Esconder Loading
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        
        // Toast Notification
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show';
            if (type) toast.classList.add(type);
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        // Atualizar Status da Conexão Qdrant
        function updateQdrantStatus(status, message) {
            const statusElement = document.getElementById('qdrant-status');
            const icon = statusElement.querySelector('i');
            const text = statusElement.querySelector('span');
            
            // Resetar classes
            icon.className = 'fas fa-circle';
            
            switch(status) {
                case 'connecting':
                    icon.style.color = '#F59E0B';
                    icon.className = 'fas fa-spinner fa-spin';
                    text.style.color = '#F59E0B';
                    break;
                case 'connected':
                    icon.style.color = '#10B981';
                    text.style.color = '#10B981';
                    break;
                case 'error':
                    icon.style.color = '#EF4444';
                    text.style.color = '#EF4444';
                    break;
                default:
                    icon.style.color = '#94A3B8';
                    text.style.color = '#94A3B8';
            }
            
            text.textContent = message;
        }
        
        /**
         * Carregar dados reais do Qdrant (chamado automaticamente na inicialização)
         */
        async function loadRealData() {
            if (!qdrantConnector) return;
            
            showLoading(true);
            
            try {
                const realData = await qdrantConnector.getAllData();
                
                // Atualizar listas com dados reais
                updateDataListsFromRealData(realData);
                
                // Gerar grafo automático se houver dados suficientes
                if (realData.metadata.totalNodes > 3) {
                    setTimeout(() => {
                        generateGraphFromQdrant(realData);
                    }, 2000);
                }
                
            } catch (error) {
                console.error('Erro ao carregar dados reais:', error);
                showToast('Erro ao conectar com Qdrant', 'error');
                loadDataLists(); // Usar dados mock como fallback
            } finally {
                showLoading(false);
            }
        }
        
        /**
         * Conectar manualmente com Qdrant (botão na toolbar)
         */
        async function connectQdrant() {
            if (!qdrantConnector) {
                qdrantConnector = new QdrantConnector();
            }
            
            showLoading(true);
            showToast('Reconectando com Qdrant...', 'info');
            
            try {
                // Limpar cache para forçar nova busca
                qdrantConnector.cache.clear();
                
                const realData = await qdrantConnector.getAllData();
                
                // Limpar grafo atual
                nodes.clear();
                edges.clear();
                
                // Atualizar listas com dados atualizados
                updateDataListsFromRealData(realData);
                
                // Gerar novo grafo automático
                generateGraphFromQdrant(realData);
                
                showToast('Conectado com Qdrant! Grafo regenerado', 'success');
                
            } catch (error) {
                console.error('Erro ao conectar com Qdrant:', error);
                showToast('Erro ao conectar com Qdrant', 'error');
            } finally {
                showLoading(false);
            }
        }
        
        /**
         * Atualizar listas com dados reais do Qdrant
         */
        function updateDataListsFromRealData(realData) {
            // Atualizar categorias
            const categoriesList = document.getElementById('categories-list');
            categoriesList.innerHTML = '';
            realData.categories.forEach(cat => {
                categoriesList.innerHTML += createSelectableItem('category', cat);
            });
            
            // Atualizar arquivos
            const filesList = document.getElementById('files-list');
            filesList.innerHTML = '';
            realData.files.forEach(file => {
                filesList.innerHTML += createSelectableItem('file', file);
            });
            
            // Atualizar entidades
            const entitiesList = document.getElementById('entities-list');
            entitiesList.innerHTML = '';
            realData.entities.forEach(entity => {
                entitiesList.innerHTML += createSelectableItem('entity', entity);
            });
            
            console.log('✅ Listas atualizadas com dados do Qdrant');
        }
        
        /**
         * Gerar grafo automaticamente baseado nos dados do Qdrant
         */
        function generateGraphFromQdrant(realData) {
            console.log('🎨 Gerando grafo automático com dados do Qdrant');
            
            // Criar nó central do Knowledge Base
            const centerNodeId = 'knowledge-center';
            if (!nodes.get(centerNodeId)) {
                nodes.add({
                    id: centerNodeId,
                    label: 'Knowledge Base',
                    color: '#6366F1',
                    size: 50,
                    shape: 'hexagon',
                    font: { size: 18, bold: true, color: '#FFFFFF' },
                    x: 0,
                    y: 0,
                    physics: false,
                    title: `Base de Conhecimento\\nCarregada do Qdrant\\n${realData.metadata.totalNodes} itens`
                });
            }
            
            // Adicionar categorias em círculo ao redor do centro
            const categoryRadius = 200;
            realData.categories.forEach((category, index) => {
                const angle = (2 * Math.PI * index) / realData.categories.length;
                const x = categoryRadius * Math.cos(angle);
                const y = categoryRadius * Math.sin(angle);
                
                const nodeId = `category-${category.id}`;
                nodes.add({
                    id: nodeId,
                    label: category.name,
                    color: category.color,
                    shape: 'square',
                    size: 25 + (category.count / 10), // Tamanho baseado na quantidade
                    x: x,
                    y: y,
                    physics: false,
                    title: `Categoria: ${category.name}\\n${category.count} arquivos`
                });
                
                // Conectar categoria ao centro
                edges.add({
                    id: `edge-center-${nodeId}`,
                    from: centerNodeId,
                    to: nodeId,
                    width: 3,
                    color: category.color,
                    title: 'Categoria principal'
                });
            });
            
            // Adicionar arquivos de alta relevância
            const highRelevanceFiles = realData.files.filter(f => f.relevance > 70);
            const fileRadius = 350;
            
            highRelevanceFiles.forEach((file, index) => {
                const angle = (2 * Math.PI * index) / highRelevanceFiles.length;
                const x = fileRadius * Math.cos(angle);
                const y = fileRadius * Math.sin(angle);
                
                const nodeId = `file-${file.id}`;
                const nodeColor = file.relevance > 90 ? '#EF4444' : file.relevance > 80 ? '#F59E0B' : '#3B82F6';
                
                nodes.add({
                    id: nodeId,
                    label: file.name.substring(0, 15) + (file.name.length > 15 ? '...' : ''),
                    color: nodeColor,
                    shape: 'dot',
                    size: 15 + (file.relevance / 10),
                    x: x,
                    y: y,
                    physics: false,
                    title: `Arquivo: ${file.name}\\nRelevância: ${file.relevance}%\\nTamanho: ${file.size}`
                });
                
                // Conectar arquivo à categoria mais próxima
                if (file.categories && file.categories.length > 0) {
                    const categoryId = `category-${file.categories[0]}`;
                    if (nodes.get(categoryId)) {
                        edges.add({
                            id: `edge-${nodeId}-${categoryId}`,
                            from: categoryId,
                            to: nodeId,
                            width: 1,
                            color: { color: '#64748b', opacity: 0.6 },
                            dashes: true,
                            title: 'Arquivo da categoria'
                        });
                    }
                } else {
                    // Se não tem categoria, conectar ao centro
                    edges.add({
                        id: `edge-center-${nodeId}`,
                        from: centerNodeId,
                        to: nodeId,
                        width: 1,
                        color: { color: '#94a3b8', opacity: 0.4 },
                        dashes: true,
                        title: 'Arquivo sem categoria'
                    });
                }
            });
            
            // Adicionar entidades principais
            const topEntities = realData.entities.slice(0, 8); // Top 8 entidades
            const entityRadius = 280;
            
            topEntities.forEach((entity, index) => {
                const angle = (2 * Math.PI * index) / topEntities.length + Math.PI/4; // Offset para não sobrepor
                const x = entityRadius * Math.cos(angle);
                const y = entityRadius * Math.sin(angle);
                
                const nodeId = `entity-${entity.id}`;
                let entityColor = '#8B5CF6';
                
                // Cores baseadas no status
                switch(entity.status.toLowerCase()) {
                    case 'ativo': entityColor = '#10B981'; break;
                    case 'negociação': entityColor = '#F59E0B'; break;
                    case 'qualificado': entityColor = '#3B82F6'; break;
                }
                
                nodes.add({
                    id: nodeId,
                    label: entity.name,
                    color: entityColor,
                    shape: 'diamond',
                    size: 20,
                    x: x,
                    y: y,
                    physics: false,
                    title: `Entidade: ${entity.name}\\nTipo: ${entity.type}\\nStatus: ${entity.status}`
                });
                
                // Conectar entidade ao centro
                edges.add({
                    id: `edge-center-${nodeId}`,
                    from: centerNodeId,
                    to: nodeId,
                    width: 2,
                    color: { color: entityColor, opacity: 0.7 },
                    title: 'Entidade principal'
                });
            });
            
            // Adicionar cadeias de convergência se existirem
            if (realData.convergenceChains && realData.convergenceChains.length > 0) {
                realData.convergenceChains.forEach((chain, index) => {
                    const nodeId = `convergence-${chain.id}`;
                    nodes.add({
                        id: nodeId,
                        label: chain.name,
                        color: '#EC4899',
                        shape: 'star',
                        size: 15 + (chain.strength * 10),
                        title: `Padrão: ${chain.name}\\nForça: ${Math.round(chain.strength * 100)}%\\nTipo: ${chain.type}`
                    });
                    
                    // Conectar convergência ao centro
                    edges.add({
                        id: `edge-center-${nodeId}`,
                        from: centerNodeId,
                        to: nodeId,
                        width: Math.round(chain.strength * 3),
                        color: { color: '#EC4899', opacity: 0.8 },
                        title: 'Padrão de convergência'
                    });
                });
            }
            
            // Habilitar física após layout inicial
            setTimeout(() => {
                nodes.forEach(node => {
                    if (node.id !== centerNodeId) { // Manter centro fixo
                        nodes.update({ id: node.id, physics: true });
                    }
                });
            }, 3000);
            
            // Atualizar lista de correlações
            updateCorrelationList();
            
            showToast(`Grafo gerado: ${realData.metadata.totalNodes} nós, ${realData.metadata.totalConnections} conexões`, 'success');
            console.log('✅ Grafo automático gerado com sucesso');
        }
        
        /**
         * Mostrar modal de configuração do Qdrant
         */
        function showQdrantConfigModal() {
            const modal = document.getElementById('qdrant-config-modal');
            modal.classList.add('show');
            
            // Carregar configurações atuais
            document.getElementById('qdrant-url').value = qdrantConnector?.baseUrl || 'http://localhost:6333';
            document.getElementById('qdrant-collection').value = qdrantConnector?.collectionName || '';
        }
        
        /**
         * Fechar modal de configuração
         */
        function closeQdrantConfigModal() {
            document.getElementById('qdrant-config-modal').classList.remove('show');
            document.getElementById('connection-status').style.display = 'none';
        }
        
        /**
         * Testar conexão com configurações do modal
         */
        async function testQdrantConnection() {
            const url = document.getElementById('qdrant-url').value;
            const collection = document.getElementById('qdrant-collection').value;
            const statusDiv = document.getElementById('connection-status');
            
            statusDiv.style.display = 'block';
            statusDiv.style.backgroundColor = '#F59E0B20';
            statusDiv.style.color = '#F59E0B';
            statusDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testando conexão...';
            
            try {
                const response = await fetch(`${url}/collections`);
                
                if (response.ok) {
                    const data = await response.json();
                    const collections = data.result?.collections || [];
                    
                    statusDiv.style.backgroundColor = '#10B98120';
                    statusDiv.style.color = '#10B981';
                    
                    if (collections.length > 0) {
                        const collectionNames = collections.map(c => c.name);
                        statusDiv.innerHTML = `
                            <i class="fas fa-check-circle"></i> Conectado com sucesso!<br>
                            <small>Coleções disponíveis: ${collectionNames.join(', ')}</small>
                        `;
                        
                        // Se não especificou coleção, sugerir uma
                        if (!collection && collections.length > 0) {
                            const knowledgeCollection = collections.find(c => 
                                c.name.toLowerCase().includes('knowledge') ||
                                c.name.toLowerCase().includes('base') ||
                                c.name.toLowerCase().includes('consolidat')
                            );
                            
                            if (knowledgeCollection) {
                                document.getElementById('qdrant-collection').value = knowledgeCollection.name;
                                statusDiv.innerHTML += `<br><small>💡 Sugestão: Usando "${knowledgeCollection.name}"</small>`;
                            } else {
                                document.getElementById('qdrant-collection').value = collections[0].name;
                                statusDiv.innerHTML += `<br><small>💡 Sugestão: Usando "${collections[0].name}"</small>`;
                            }
                        }
                    } else {
                        statusDiv.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Conectado, mas nenhuma coleção encontrada';
                    }
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                statusDiv.style.backgroundColor = '#EF444420';
                statusDiv.style.color = '#EF4444';
                statusDiv.innerHTML = `
                    <i class="fas fa-times-circle"></i> Erro na conexão: ${error.message}<br>
                    <small>Verifique se o Qdrant está rodando em ${url}</small>
                `;
            }
        }
        
        /**
         * Conectar com configurações personalizadas
         */
        async function connectWithConfig() {
            const url = document.getElementById('qdrant-url').value;
            const collection = document.getElementById('qdrant-collection').value;
            
            if (!url) {
                showToast('Informe a URL do Qdrant', 'error');
                return;
            }
            
            // Atualizar configurações do connector
            qdrantConnector.baseUrl = url;
            qdrantConnector.collectionName = collection || 'knowledge_base';
            qdrantConnector.cache.clear();
            qdrantConnector.connected = false;
            
            closeQdrantConfigModal();
            
            // Tentar conectar com novas configurações
            await connectQdrant();
        }
        
        /**
         * Carregar dados de arquivo JSON
         */
        function loadDataFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    
                    // Verificar se é um formato válido
                    if (data.categories && data.files) {
                        // Formato direto
                        updateDataListsFromRealData(data);
                        generateGraphFromQdrant(data);
                        updateQdrantStatus('connected', `Arquivo carregado (${data.categories.length + data.files.length + (data.entities?.length || 0)} itens)`);
                        showToast('Dados carregados do arquivo JSON!', 'success');
                    } else if (data.result && Array.isArray(data.result)) {
                        // Formato Qdrant (array de pontos)
                        const convertedData = convertQdrantToGraphData(data.result);
                        updateDataListsFromRealData(convertedData);
                        generateGraphFromQdrant(convertedData);
                        updateQdrantStatus('connected', `Dados Qdrant (${convertedData.metadata.totalNodes} itens)`);
                        showToast('Dados Qdrant carregados!', 'success');
                    } else {
                        throw new Error('Formato de arquivo não suportado');
                    }
                    
                    closeQdrantConfigModal();
                } catch (error) {
                    showToast(`Erro ao carregar arquivo: ${error.message}`, 'error');
                }
            };
            
            input.click();
        }
        
        /**
         * Converter dados brutos do Qdrant para formato do grafo
         */
        function convertQdrantToGraphData(points) {
            const categories = [];
            const files = [];
            const entities = [];
            
            points.forEach(point => {
                const payload = point.payload || {};
                const type = payload.type || 'unknown';
                
                switch(type.toLowerCase()) {
                    case 'category':
                        categories.push({
                            id: payload.category_id || point.id,
                            name: payload.category_name || payload.name || 'Categoria sem nome',
                            color: payload.color || '#3B82F6',
                            count: payload.file_count || 0
                        });
                        break;
                    case 'file':
                        files.push({
                            id: payload.file_id || point.id,
                            name: payload.filename || payload.name || 'Arquivo sem nome',
                            size: formatFileSize(payload.file_size || 0),
                            relevance: Math.round((point.score || 0.5) * 100),
                            categories: payload.categories || []
                        });
                        break;
                    case 'entity':
                        entities.push({
                            id: payload.entity_id || point.id,
                            name: payload.entity_name || payload.name || 'Entidade sem nome',
                            type: payload.entity_type || 'Entity',
                            status: payload.status || 'Ativo'
                        });
                        break;
                }
            });
            
            return {
                categories,
                files,
                entities,
                convergenceChains: [],
                metadata: {
                    totalNodes: categories.length + files.length + entities.length,
                    totalConnections: 0,
                    lastSync: new Date().toISOString(),
                    source: 'JSON File'
                }
            };
        }
        
        /**
         * Carregar dados de exemplo (para demonstração)
         */
        function loadSampleData() {
            const sampleData = {
                categories: [
                    { id: 'vendas', name: 'Vendas', count: 45, color: '#10B981' },
                    { id: 'marketing', name: 'Marketing', count: 32, color: '#3B82F6' },
                    { id: 'desenvolvimento', name: 'Desenvolvimento', count: 28, color: '#8B5CF6' },
                    { id: 'estrategia', name: 'Estratégia', count: 15, color: '#EF4444' }
                ],
                files: [
                    { id: 'prop1', name: 'proposta_cliente_premium.pdf', size: '2.4 MB', relevance: 95, categories: ['vendas'] },
                    { id: 'rel1', name: 'relatorio_vendas_q4.xlsx', size: '1.8 MB', relevance: 88, categories: ['vendas'] },
                    { id: 'camp1', name: 'campanha_digital_2025.pptx', size: '5.2 MB', relevance: 82, categories: ['marketing'] },
                    { id: 'api1', name: 'documentacao_api_v2.md', size: '156 KB', relevance: 90, categories: ['desenvolvimento'] },
                    { id: 'est1', name: 'planejamento_estrategico.docx', size: '1.1 MB', relevance: 93, categories: ['estrategia'] }
                ],
                entities: [
                    { id: 'cliente1', name: 'TechCorp Solutions', type: 'Cliente', status: 'Ativo' },
                    { id: 'prospect1', name: 'InnovateX Labs', type: 'Prospect', status: 'Negociação' },
                    { id: 'parceiro1', name: 'Digital Partners', type: 'Parceiro', status: 'Ativo' },
                    { id: 'lead1', name: 'StartupY', type: 'Lead', status: 'Qualificado' }
                ],
                metadata: {
                    totalNodes: 13,
                    totalConnections: 5,
                    lastSync: new Date().toISOString(),
                    source: 'Sample Data'
                }
            };
            
            updateDataListsFromRealData(sampleData);
            generateGraphFromQdrant(sampleData);
            updateQdrantStatus('connected', `Dados de exemplo (${sampleData.metadata.totalNodes} itens)`);
            showToast('Dados de exemplo carregados!', 'success');
            closeQdrantConfigModal();
        }
        
        // Carregar Mock Data inicial (fallback)
        function loadMockData() {
            loadDataLists(); // Usar dados mock das variáveis globais
        }
        
        // FUNÇÕES FALTANTES - Correção do erro
        
        // Mostrar detalhes do nó quando clicado
        function showNodeDetails(nodeId) {
            console.log('Node clicked:', nodeId);
            const node = nodes.get(nodeId);
            if (node) {
                showToast(`Selecionado: ${node.label}`, 'info');
                
                // Destacar o nó selecionado
                nodes.update({
                    id: nodeId,
                    borderWidth: 3,
                    borderColor: '#3B82F6'
                });
                
                // Remover destaque após 3 segundos
                setTimeout(() => {
                    nodes.update({
                        id: nodeId,
                        borderWidth: 2,
                        borderColor: 'inherit'
                    });
                }, 3000);
            }
        }
        
        // Editar nó quando duplo-clicado
        function editNode(nodeId) {
            console.log('Node double-clicked for editing:', nodeId);
            const node = nodes.get(nodeId);
            if (node) {
                const newLabel = prompt(`Editar rótulo do nó:`, node.label);
                if (newLabel && newLabel.trim() !== '') {
                    nodes.update({
                        id: nodeId,
                        label: newLabel.trim()
                    });
                    showToast(`Nó "${node.label}" renomeado para "${newLabel.trim()}"`, 'success');
                }
            }
        }
    </script>
</body>
</html>