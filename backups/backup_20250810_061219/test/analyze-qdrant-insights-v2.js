// Script robusto para analisar insights dos dados no Qdrant
// Com tratamento de erros e valida√ß√µes

async function analyzeQdrantInsights() {
    console.log('üîç AN√ÅLISE DE INSIGHTS - QDRANT ENRICHED DATA\n');
    console.log('Data:', new Date().toISOString());
    console.log('=' .repeat(60) + '\n');

    try {
        // 1. Primeiro verificar se o Qdrant est√° acess√≠vel
        console.log('üîå Verificando conex√£o com Qdrant...');
        const testResponse = await fetch('http://qdr.vcia.com.br:6333/');
        if (!testResponse.ok) {
            throw new Error('Qdrant n√£o est√° acess√≠vel');
        }
        console.log('‚úÖ Qdrant conectado!\n');

        // 2. Listar cole√ß√µes dispon√≠veis
        console.log('üìö Cole√ß√µes dispon√≠veis:');
        const collectionsResponse = await fetch('http://qdr.vcia.com.br:6333/collections');
        const collections = await collectionsResponse.json();
        
        if (collections.result && collections.result.collections) {
            collections.result.collections.forEach(col => {
                console.log(`   - ${col.name}`);
            });
        }
        console.log('');

        // 3. Verificar especificamente a cole√ß√£o kc_enriched
        const collectionName = 'kc_enriched';
        console.log(`üìä Analisando cole√ß√£o: ${collectionName}\n`);
        
        const statsResponse = await fetch(`http://qdr.vcia.com.br:6333/collections/${collectionName}`);
        if (!statsResponse.ok) {
            console.log('‚ö†Ô∏è  Cole√ß√£o kc_enriched n√£o encontrada. Tentando kc_documents...');
            // Tentar cole√ß√£o alternativa
            const altResponse = await fetch('http://qdr.vcia.com.br:6333/collections/kc_documents');
            if (!altResponse.ok) {
                throw new Error('Nenhuma cole√ß√£o KC encontrada');
            }
            collectionName = 'kc_documents';
        }

        const stats = await statsResponse.json();
        
        if (stats.result) {
            console.log(`Total de Pontos: ${stats.result.points_count || 0}`);
            console.log(`Status: ${stats.result.status || 'unknown'}`);
            if (stats.result.config && stats.result.config.params && stats.result.config.params.vectors) {
                console.log(`Dimens√µes: ${stats.result.config.params.vectors.size || 'N/A'}`);
            }
        }
        console.log('');

        // 4. Buscar alguns pontos para an√°lise
        console.log('üìã Buscando dados para an√°lise...\n');
        
        // Primeiro tentar scroll
        let points = [];
        try {
            const scrollResponse = await fetch(`http://qdr.vcia.com.br:6333/collections/${collectionName}/points/scroll`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    limit: 50,
                    with_payload: true,
                    with_vector: false
                })
            });
            
            if (scrollResponse.ok) {
                const scrollData = await scrollResponse.json();
                if (scrollData.result && scrollData.result.points) {
                    points = scrollData.result.points;
                }
            }
        } catch (error) {
            console.log('‚ö†Ô∏è  Scroll falhou, tentando search...');
        }

        // Se scroll falhou, tentar search
        if (points.length === 0) {
            try {
                const searchResponse = await fetch(`http://qdr.vcia.com.br:6333/collections/${collectionName}/points/search`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        vector: Array(768).fill(0.1), // Vector dummy
                        limit: 50,
                        with_payload: true,
                        with_vector: false
                    })
                });
                
                if (searchResponse.ok) {
                    const searchData = await searchResponse.json();
                    if (searchData.result) {
                        points = searchData.result;
                    }
                }
            } catch (error) {
                console.log('‚ö†Ô∏è  Search tamb√©m falhou');
            }
        }

        if (points.length === 0) {
            console.log('‚ùå N√£o foi poss√≠vel recuperar dados da cole√ß√£o');
            return;
        }

        console.log(`‚úÖ ${points.length} pontos recuperados para an√°lise\n`);

        // 5. An√°lise dos dados
        console.log('üéØ AN√ÅLISE DOS DADOS:\n');
        
        const intelligenceTypes = {};
        const analysisTypes = {};
        const categories = new Map();
        const convergenceScores = [];
        const fileNames = new Set();
        const insights = [];
        
        points.forEach(point => {
            const payload = point.payload || {};
            
            // Tipos de intelig√™ncia
            if (payload.intelligenceType) {
                intelligenceTypes[payload.intelligenceType] = (intelligenceTypes[payload.intelligenceType] || 0) + 1;
            }
            
            // Tipos de an√°lise
            if (payload.analysisType) {
                analysisTypes[payload.analysisType] = (analysisTypes[payload.analysisType] || 0) + 1;
            }
            
            // Scores
            if (typeof payload.convergenceScore === 'number') {
                convergenceScores.push(payload.convergenceScore);
            }
            
            // Categorias
            if (Array.isArray(payload.categories)) {
                payload.categories.forEach(cat => {
                    const catName = typeof cat === 'object' ? (cat.name || cat.id) : cat;
                    if (catName) {
                        categories.set(catName, (categories.get(catName) || 0) + 1);
                    }
                });
            }
            
            // Arquivos
            if (payload.fileName) {
                fileNames.add(payload.fileName);
            }
            
            // Coletar insights se existirem
            if (payload.insights && payload.insights.length > 0) {
                insights.push(...payload.insights);
            }
        });
        
        // Exibir resultados
        if (Object.keys(intelligenceTypes).length > 0) {
            console.log('üìä Distribui√ß√£o de Intelligence Types:');
            Object.entries(intelligenceTypes)
                .sort((a, b) => b[1] - a[1])
                .forEach(([type, count]) => {
                    const percentage = ((count / points.length) * 100).toFixed(1);
                    console.log(`   ${type}: ${count} (${percentage}%)`);
                });
        } else {
            console.log('‚ùå Nenhum intelligenceType encontrado');
        }
        
        console.log('');
        
        if (Object.keys(analysisTypes).length > 0) {
            console.log('üìà Distribui√ß√£o de Analysis Types:');
            Object.entries(analysisTypes)
                .sort((a, b) => b[1] - a[1])
                .forEach(([type, count]) => {
                    const percentage = ((count / points.length) * 100).toFixed(1);
                    console.log(`   ${type}: ${count} (${percentage}%)`);
                });
        } else {
            console.log('‚ùå Nenhum analysisType encontrado');
        }
        
        console.log('');
        
        if (categories.size > 0) {
            console.log('üìÅ Top 10 Categorias:');
            Array.from(categories.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .forEach(([cat, count]) => {
                    console.log(`   ${cat}: ${count} ocorr√™ncias`);
                });
        }
        
        console.log('');
        
        if (convergenceScores.length > 0) {
            const avgScore = convergenceScores.reduce((a, b) => a + b, 0) / convergenceScores.length;
            const maxScore = Math.max(...convergenceScores);
            const minScore = Math.min(...convergenceScores);
            
            console.log('üìä Estat√≠sticas de Convergence Score:');
            console.log(`   M√©dia: ${avgScore.toFixed(3)}`);
            console.log(`   M√°ximo: ${maxScore.toFixed(3)}`);
            console.log(`   M√≠nimo: ${minScore.toFixed(3)}`);
        }
        
        console.log(`\nüìÑ Arquivos √∫nicos identificados: ${fileNames.size}`);
        
        if (insights.length > 0) {
            console.log(`\nüí° Insights extra√≠dos: ${insights.length}`);
            console.log('   Primeiros 3 insights:');
            insights.slice(0, 3).forEach((insight, idx) => {
                const text = typeof insight === 'object' ? insight.content : insight;
                console.log(`   ${idx + 1}. ${text?.substring(0, 100)}...`);
            });
        }
        
        // 6. An√°lise de qualidade
        console.log('\n\nüîç AN√ÅLISE DE QUALIDADE:\n');
        
        let qualityIssues = [];
        
        // Verificar dados incompletos
        let incomplete = 0;
        points.forEach(point => {
            const p = point.payload || {};
            if (!p.content || !p.analysisType || !p.categories || p.categories.length === 0) {
                incomplete++;
            }
        });
        
        if (incomplete > 0) {
            qualityIssues.push(`${incomplete} pontos (${((incomplete/points.length)*100).toFixed(1)}%) com dados incompletos`);
        }
        
        // Verificar distribui√ß√£o
        if (Object.keys(intelligenceTypes).length < 3) {
            qualityIssues.push('Baixa diversidade de tipos de intelig√™ncia');
        }
        
        if (avgScore && avgScore < 0.3) {
            qualityIssues.push('Convergence scores muito baixos em m√©dia');
        }
        
        if (qualityIssues.length > 0) {
            console.log('‚ö†Ô∏è  Problemas identificados:');
            qualityIssues.forEach(issue => console.log(`   - ${issue}`));
        } else {
            console.log('‚úÖ Qualidade geral dos dados est√° boa!');
        }
        
        // 7. Recomenda√ß√µes
        console.log('\nüí° RECOMENDA√á√ïES:\n');
        
        if (points.length < 100) {
            console.log('   1. Processar mais documentos para ter uma base mais robusta');
        }
        
        if (Object.keys(intelligenceTypes).length < 4) {
            console.log('   2. Revisar classificador para identificar mais tipos de intelig√™ncia');
        }
        
        if (categories.size < 5) {
            console.log('   3. Enriquecer categoriza√ß√£o dos documentos');
        }
        
        if (insights.length === 0) {
            console.log('   4. Ativar extra√ß√£o de insights no pipeline');
        }
        
        console.log('\n' + '='.repeat(60));
        console.log('‚úÖ An√°lise conclu√≠da com sucesso!');
        
    } catch (error) {
        console.error('\n‚ùå Erro durante an√°lise:', error.message);
        console.log('\nüí° Sugest√µes:');
        console.log('   1. Verificar se o Qdrant est√° acess√≠vel');
        console.log('   2. Confirmar nome da cole√ß√£o (kc_enriched ou kc_documents)');
        console.log('   3. Verificar se h√° dados na cole√ß√£o');
    }
}

// Executar
analyzeQdrantInsights();